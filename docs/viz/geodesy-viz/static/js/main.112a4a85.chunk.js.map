{"version":3,"sources":["Constants.js","Components/ControlsAndLight.js","Components/Loading.js","Components/Geoid.js","Components/Spheroids.js","CoordinateMath.js","Components/CoordinateLine.js","Components/GeoidHeightDisplay.js","Components/SpherePoint.js","Components/Intersections.js","Components/Legend.js","Components/Visualization.js","App.js","index.js"],"names":["GRATICULE_COLOR","ELLIPSOID_COLOR","SPHERE_COLOR","GEOCENTRIC_LINE_COLOR","GEODETIC_LINE_COLOR","GEOID_HEIGHT_CONTROL","GEOID_CONTROL","MODELS_FOLDER","COORDINATES_FOLDER","GEOID_NAME","SetCameraLayers","camera","useThree","useEffect","layers","enable","FreeControlsWithClickDetection","useControls","autoRotate","value","hint","set","window","addEventListener","console","log","FreeControls","gl","controls","useRef","useFrame","current","update","OrbitControls","ref","args","minDistance","MODEL_RADIUS","maxDistance","enablePan","autoRotateSpeed","CameraAlignedLight","light","matrixAutoUpdate","intensity","min","max","followCamera","offset","step","collapsed","matrix","copy","cameraMatrix","offsetDegrees","frameMatrix","clone","setPosition","frameMatrixInv","invert","rotationMatrix","THREE","makeRotationY","MathUtils","degToRad","multiply","calculateLightMatrix","matrixWorld","LoadingScreen","Html","transform","fullscreen","className","GEOID_MODEL_PATH","Geoid","isVisible","fallback","GeoidModel","useGLTF","nodes","materials","dispose","geometry","Sphere","material","GeoidFlatMaterial","name","scale","visible","preload","props","ScaledSphere","Ellipsoid","flattening","semimajorAxis","sphereGeometry","useMemo","SphereBufferGeometry","radius","WIDTH_SEGMENTS","opacity","attach","color","transparent","edgeColor","depthWrite","geocentricEllipsoidIntersection","lat","lon","latRad","lonRad","z","Math","cos","x","sin","y","R","sqrt","multiplyScalar","geocentricToWorld","height","longitudeDeg","latitudeDeg","theta","phi","setFromSphericalCoords","geodeticToWorld","eSquared","N","getGeodeticOrigin","GeocentricCoordinateLine","latitude","longitude","lineColor","MovingLine","start","end","GeodeticCoordinateLine","renderOrder","bufferGeometryRef","useLayoutEffect","vertices","setFromPoints","geoidHeightCanvasId","GeoidHeightCanvas","canvasRef","image","Image","src","onload","getContext","drawImage","hidden","id","width","CenteredText","text","zIndexRange","style","calculatePosition","el","size","GeoidHeightDisplay","geoidHeight","context","getImgXYFromCoordinates","imgX","imgY","pixelValue","minHeight","round","pixelToGeoidHeight","getImageData","data","lookupGeoidHeight","document","getElementById","NORMAL_COLOR","SpherePoint","position","materialRef","useState","hover","setHover","onPointerOver","onPointerOut","SphereIntersection","GeocentricEllipsoidIntersection","GeodeticEllipsoidIntersection","GeocentricRaycastIntersectionByName","objectName","rayStart","RaycastIntersectionByName","direction","negate","GeodeticRaycastIntersectionByName","sub","scene","raycaster","r","normalize","modelIntersection","intersectObjects","children","find","intersection","object","point","LegendWrapper","gradientLegend","elementsLegend","prepend","GradientLegend","top","middle","bottom","alt","Legend","elements","Object","keys","map","label","LegendElement","block","LineBlock","borderWidth","borderStyle","borderColor","ImageBlock","ColorBlock","backgroundColor","Visualization","folder","render","buttonGroup","geodetic","get","geocentric","geoidHeightMode","Models","sphere","ellipsoid","onChange","transient","geoid","setGeoid","legend","getLegendElements","App","Stats","hideCopyButton","ReactDOM"],"mappings":"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","file":"static/js/main.112a4a85.chunk.js","sourcesContent":["/**\r\n * Colors of the objects in the visualization.\r\n */\r\nexport const GRATICULE_COLOR = \"#ffffff\";\r\nexport const ELLIPSOID_COLOR = \"#5e78ce\";\r\nexport const SPHERE_COLOR = \"#d074b3\";\r\nexport const GEOCENTRIC_LINE_COLOR = \"#0047fd\";\r\nexport const GEODETIC_LINE_COLOR = \"#d30000\";\r\n\r\n/**\r\n * This value determines the size of the three models. In the sphere/ellipsoid case, it is used to specify the radius of\r\n * the geometry (before scaling).\r\n */\r\nexport const MODEL_RADIUS = 1;\r\n\r\n/**\r\n * The layer the models are placed into for more efficient raycasting.\r\n */\r\nexport const MODEL_LAYER = 5;\r\n\r\n/**\r\n * Constant flattening factor of the WGS84 ellipsoid.\r\n */\r\nexport const WGS_FLATTENING = 1 / 298.257223560;\r\n\r\n/**\r\n * Name of the control that controls the geoid height view.\r\n */\r\nexport const GEOID_HEIGHT_CONTROL = \"geoidHeight\";\r\n\r\n/**\r\n * Displayed name of the Leva control that shows/hides the geoid.\r\n */\r\nexport const GEOID_CONTROL = \"show geoid?\";\r\n\r\n/**\r\n * Names of the Leva folders for models and coordinates.\r\n */\r\nexport const MODELS_FOLDER = \"Models\";\r\nexport const COORDINATES_FOLDER = \"Coordinates\";\r\n\r\n/**\r\n * Tooltip text for the Leva controls.\r\n */\r\nexport const GEOID_CONTROL_HINT = \"Show/hide the geoid\";\r\nexport const SPHERE_CONTROL_HINT = \"Visibility of the sphere\";\r\nexport const ELLIPSOID_CONTROL_HINT = \"Visibility of the ellipsoid\";\r\nexport const FLATTENING_CONTROL_HINT = \"Flattening factor of the ellipsoid\";\r\n\r\nexport const LATITUDE_CONTROL_HINT = \"Latitude (degrees)\";\r\nexport const LONGITUDE_CONTROL_HINT = \"Longitude (degrees)\";\r\nexport const GEODETIC_CONTROL_HINT = \"Show as geodetic coordinates\";\r\nexport const GEOCENTRIC_CONTROL_HINT = \"Show as geocentric coordinates\";\r\n\r\nexport const AUTOROTATE_HINT = \"Automatically rotate around models\";\r\n\r\nexport const LIGHT_INTENSITY_HINT = \"Light intensity\";\r\nexport const LIGHT_FOLLOW_HINT = \"Make the light rotate with you\";\r\nexport const LIGHT_OFFSET_HINT = \"Lighting angle, in degrees\";\r\n\r\n/**\r\n * Number of width and height segments of the sphere and ellipsoid.\r\n */\r\nexport const WIDTH_SEGMENTS = 48;\r\nexport const HEIGHT_SEGMENTS = WIDTH_SEGMENTS / 2;\r\n\r\n/**\r\n * The name associated with the geoid model object (used to identify the geoid).\r\n */\r\nexport const GEOID_NAME = \"geoid\";","import { useFrame, useThree } from \"@react-three/fiber\";\r\nimport React, { useEffect, useRef } from \"react\";\r\nimport { OrbitControls } from \"@react-three/drei\";\r\nimport * as THREE from \"three\";\r\nimport { MathUtils } from \"three\";\r\nimport { useControls } from \"leva\";\r\nimport {\r\n    AUTOROTATE_HINT,\r\n    LIGHT_FOLLOW_HINT,\r\n    LIGHT_INTENSITY_HINT,\r\n    LIGHT_OFFSET_HINT,\r\n    MODEL_LAYER,\r\n    MODEL_RADIUS\r\n} from \"../Constants\";\r\n\r\n/**\r\n * Extends the default camera layers to include the layer we moved all models into.\r\n * This is required because we placed the primary models (sphere, ellipsoid, geoid) in a different layer to raycast\r\n * against them.\r\n */\r\nexport function SetCameraLayers() {\r\n    const { camera } = useThree();\r\n\r\n    useEffect(() => {\r\n        camera.layers.enable(MODEL_LAYER);\r\n    }, [camera.layers]);\r\n\r\n    return null;\r\n}\r\n\r\n/**\r\n * OrbitControls with some predefined camera settings, including auto-rotation and disabling panning.\r\n * Auto-rotation is initially on, and the first click turns it off.\r\n *\r\n * Adds the Camera folder to the Leva controls to toggle the auto-rotation.\r\n */\r\nexport function FreeControlsWithClickDetection() {\r\n    const [{ autoRotate }, set] = useControls(\"Camera\", () => ({\r\n        autoRotate: {\r\n            value: true,\r\n            hint: AUTOROTATE_HINT,\r\n        },\r\n    }));\r\n\r\n    useEffect(() => {\r\n        const stopRotating = () => {\r\n            console.log(\"Turning off auto rotation\");\r\n            set({ autoRotate: false });\r\n        };\r\n\r\n        window.addEventListener(\"click\", stopRotating, {\"once\": true});\r\n    }, [set]);\r\n\r\n    return (\r\n        <FreeControls autoRotate={autoRotate}/>\r\n    );\r\n}\r\n\r\nfunction FreeControls({ autoRotate }) {\r\n    const { camera, gl } = useThree();\r\n    const controls = useRef();\r\n\r\n    useFrame(() => {\r\n        controls.current.update();\r\n    });\r\n\r\n    return (\r\n        <OrbitControls\r\n            ref={controls}\r\n            args={[camera, gl]}\r\n            minDistance={MODEL_RADIUS + 0.5}\r\n            maxDistance={MODEL_RADIUS * 10}\r\n\r\n            enablePan={false}\r\n\r\n            autoRotate={autoRotate}\r\n            autoRotateSpeed={0.5}\r\n        />\r\n    );\r\n}\r\n\r\n/**\r\n * A directional light that shines from a fixed angle relative to the camera.\r\n *\r\n * Adds the Lighting folder to the Leva controls.\r\n */\r\nexport function CameraAlignedLight() {\r\n\r\n    const light = useRef();\r\n    useEffect(() => {\r\n        light.current.matrixAutoUpdate = false;\r\n    }, []);\r\n\r\n    const { camera } = useThree();\r\n\r\n    const { intensity, followCamera, offset } = useControls(\"Lighting\", {\r\n        intensity: {\r\n            value: 0.75,\r\n            min: 0,\r\n            max: 2,\r\n            hint: LIGHT_INTENSITY_HINT,\r\n        },\r\n        followCamera: {\r\n            value: true,\r\n            hint: LIGHT_FOLLOW_HINT,\r\n        },\r\n        offset: {\r\n            value: -65,\r\n            min: -180,\r\n            max: 180,\r\n            step: 1,\r\n            hint: LIGHT_OFFSET_HINT,\r\n        }\r\n    }, {\r\n        collapsed: true\r\n    });\r\n\r\n    useFrame(() => {\r\n        if (followCamera) {\r\n            light.current.matrix.copy(calculateLightMatrix(camera.matrixWorld, offset));\r\n        }\r\n    });\r\n\r\n    return (\r\n        <directionalLight\r\n            ref={light}\r\n            intensity={intensity}\r\n        />\r\n    );\r\n}\r\n\r\n/**\r\n * Calculates a transformation matrix for the light such that it shines from a fixed offset angle from the camera.\r\n *\r\n * Creates the illusion of rotating the models, when the user is actually rotating the camera.\r\n *\r\n * @param cameraMatrix The camera matrix (matrix that transforms positions in the camera frame to the world frame).\r\n * @param offsetDegrees The angle, in degrees, to offset the light by. A number in [-180, 180].\r\n * @returns {*} The .matrix of the light.\r\n */\r\nfunction calculateLightMatrix(cameraMatrix, offsetDegrees) {\r\n    /*\r\n    Get a frame f that has the same rotation as the camera, but is positioned at the origin of the world.\r\n    The .matrix, F, of frame f is just the camera matrix, except with the position component set to 0.\r\n     */\r\n    const frameMatrix = cameraMatrix.clone().setPosition(0, 0, 0);\r\n    const frameMatrixInv = frameMatrix.clone().invert();\r\n\r\n    /*\r\n    Construct a rotation matrix R that describes a rotation of offsetDegrees degrees about the y axis.\r\n     */\r\n    const rotationMatrix = new THREE.Matrix4().makeRotationY(MathUtils.degToRad(offsetDegrees));\r\n\r\n    /*\r\n    This matrix applies the rotation R with respect to the frame f. Applying it to the camera's local position gives the\r\n    desired world position and rotation of the light.\r\n\r\n    The matrix is calculated as F R F^(-1) C.\r\n     */\r\n    return frameMatrix.multiply(rotationMatrix).multiply(frameMatrixInv).multiply(cameraMatrix);\r\n}","import { Html } from \"@react-three/drei\";\r\nimport \"./styles/loading_screen.css\";\r\n\r\n/**\r\n * Loading screen. Covers the canvas when rendered.\r\n */\r\nexport function LoadingScreen() {\r\n    return (\r\n        <Html\r\n            transform={false}\r\n            fullscreen\r\n            className=\"loading-screen\"\r\n        >\r\n            <p className=\"loading-screen-text\">\r\n                Loading . . .\r\n            </p>\r\n        </Html>\r\n    );\r\n}","import React, { Suspense, useEffect } from \"react\";\r\nimport { useGLTF } from \"@react-three/drei\";\r\nimport { LoadingScreen } from \"./Loading\";\r\nimport { GEOID_NAME, MODEL_LAYER, MODEL_RADIUS } from \"../Constants\";\r\n\r\nconst GEOID_MODEL_PATH = \"./models/Geoid.glb\";\r\n\r\n/**\r\n * Imports the 3D model of the EGM2008 geoid (asset created specifically for this project).\r\n *\r\n * Auto-generated by: https://github.com/pmndrs/gltfjsx\r\n*/\r\nexport function Geoid({ isVisible }) {\r\n    return (\r\n        <Suspense fallback={<LoadingScreen />}>\r\n            <GeoidModel isVisible={isVisible}/>\r\n        </Suspense>\r\n    );\r\n}\r\n\r\nfunction GeoidModel({isVisible}) {\r\n    const { nodes, materials } = useGLTF(GEOID_MODEL_PATH);\r\n\r\n    useEffect(() => {\r\n        console.log(\"Loaded geoid model\");\r\n    }, []);\r\n\r\n    return (\r\n        <group dispose={null}>\r\n            <mesh\r\n                geometry={nodes.Sphere.geometry}\r\n                material={materials.GeoidFlatMaterial}\r\n\r\n                name={GEOID_NAME}\r\n                scale={MODEL_RADIUS}\r\n                layers={MODEL_LAYER}\r\n                visible={isVisible}\r\n            />\r\n        </group>\r\n    );\r\n}\r\n\r\nuseGLTF.preload(GEOID_MODEL_PATH);\r\n","import { SphereBufferGeometry } from \"three\";\r\nimport React, { useMemo } from \"react\";\r\nimport { HEIGHT_SEGMENTS, WIDTH_SEGMENTS } from \"../Constants\";\r\n\r\n/**\r\n * Displays a sphere, one of the 3 primary models in the visualization.\r\n */\r\nexport function Sphere(props) {\r\n    return (\r\n        <ScaledSphere\r\n            scale={1}\r\n            {...props}\r\n        />\r\n    );\r\n}\r\n\r\n/**\r\n * Displays an ellipsoid, one of the 3 primary models in the visualization.\r\n */\r\nexport function Ellipsoid(props) {\r\n    return (\r\n        <ScaledSphere\r\n            scale={[1, findSemiminorAxis(props.flattening, 1), 1]}\r\n            {...props}\r\n        />\r\n    );\r\n}\r\n\r\n/**\r\n * Computes the y-scale of the ellipsoid from the flattening factor.\r\n * @param flattening Flattening factor.\r\n * @param semimajorAxis The ellipsoid's x/z scales, assumed to be equal (semimajor axis).\r\n * @returns {number} The y-scale (semiminor axis).\r\n */\r\nfunction findSemiminorAxis(flattening, semimajorAxis) {\r\n    return (1 - flattening) * semimajorAxis;\r\n}\r\n\r\n/**\r\n * Draws a transparent sphere-like object with arbitrary x, y, and z scales.\r\n * This component is the basis for the sphere and ellipsoid models.\r\n */\r\nfunction ScaledSphere(props) {\r\n    const sphereGeometry = useMemo(() => {\r\n        return new SphereBufferGeometry(props.radius, WIDTH_SEGMENTS, HEIGHT_SEGMENTS);\r\n    }, [props.radius]);\r\n\r\n    return (\r\n        <group\r\n            scale={props.scale}\r\n        >\r\n            <mesh\r\n                geometry={sphereGeometry}\r\n                visible={props.opacity > 0}\r\n            >\r\n                <meshStandardMaterial\r\n                    attach=\"material\"\r\n                    color={props.color}\r\n                    transparent={true}\r\n                    opacity={props.opacity}\r\n                />\r\n            </mesh>\r\n            <lineSegments>\r\n                <edgesGeometry\r\n                    attach=\"geometry\"\r\n                    args={[sphereGeometry]}\r\n                />\r\n                <lineBasicMaterial\r\n                    attach=\"material\"\r\n                    color={props.edgeColor}\r\n                    transparent={true}\r\n                    opacity={props.opacity}\r\n                    depthWrite={false}\r\n                />\r\n            </lineSegments>\r\n        </group>\r\n    );\r\n}","import * as THREE from \"three\";\r\nimport { MathUtils } from \"three\";\r\nimport { MODEL_RADIUS } from \"./Constants\";\r\n\r\n/**\r\n * Converts a latitude angle between -90 and 90 degrees to polar angle in radians.\r\n * @param latitudeDeg Latitude, in degrees. Must be an integer value in [-90, 90].\r\n * @returns {*} Polar angle (spherical coordinates) in radians.\r\n */\r\nexport function convertLatitudeToSpherical(latitudeDeg) {\r\n    return MathUtils.degToRad(90 - latitudeDeg);\r\n}\r\n\r\n/**\r\n * Converts a longitude angle between -180 and 180 degrees to azimuthal angle in radians.\r\n * @param longitudeDeg Longitude, in degrees. Must be an integer value in [-180, 180].\r\n * @returns {*} Azimuthal angle (spherical coordinates) in radians.\r\n */\r\nexport function convertLongitudeToSpherical(longitudeDeg) {\r\n    return MathUtils.degToRad(longitudeDeg);\r\n}\r\n\r\n/**\r\n * Returns the point on the ellipsoid specified by the geocentric coordinates.\r\n * @param lat Latitude, in degrees.\r\n * @param lon Longitude, in degrees.\r\n * @param flattening Flattening factor of the ellipsoid.\r\n * @returns {Vector3} The world position of the intersection of the ellipsoid and the geocentric coordinates.\r\n */\r\nexport function geocentricEllipsoidIntersection(lat, lon, flattening) {\r\n    // World space position on the surface of the ellipsoid, from geocentric coordinates\r\n    // Formula source: https://en.wikipedia.org/wiki/Ellipsoid#Parameterization\r\n\r\n    const latRad = MathUtils.degToRad(lat);\r\n    const lonRad = MathUtils.degToRad(lon);\r\n\r\n    const z = Math.cos(latRad) * Math.cos(lonRad);\r\n    const x = Math.cos(latRad) * Math.sin(lonRad);\r\n    const y = Math.sin(latRad);\r\n\r\n    const R = (1 - flattening) * MODEL_RADIUS /\r\n        Math.sqrt(((1 - flattening) * Math.cos(latRad)) ** 2 + Math.sin(latRad) ** 2);\r\n\r\n    return new THREE.Vector3(x, y, z).multiplyScalar(R);\r\n}\r\n\r\n/**\r\n * Gets the world space coordinates from the geocentric latitude/longitude and height.\r\n * @param lat Latitude, in degrees.\r\n * @param lon Longitude, in degrees.\r\n * @param height Height (meters) above the sphere.\r\n * @returns {Vector3} The world position of the specified point.\r\n */\r\nexport function geocentricToWorld(lat, lon, height) {\r\n    const theta = convertLongitudeToSpherical(lon);\r\n    const phi = convertLatitudeToSpherical(lat);\r\n\r\n    return new THREE.Vector3().setFromSphericalCoords(MODEL_RADIUS + height, phi, theta);\r\n}\r\n\r\n/**\r\n * Gets the world space coordinates from the geodetic coordinates (latitude, longitude, ellipsoidal height).\r\n * @param lat Latitude, in degrees.\r\n * @param lon Longitude, in degrees.\r\n * @param flattening Flattening factor of the ellipsoid.\r\n * @param height Height (meters) above the ellipsoid.\r\n * @returns {Vector3} The world position of the specified point.\r\n */\r\nexport function geodeticToWorld(lat, lon, flattening, height) {\r\n    // Formula source: https://en.wikipedia.org/wiki/Geographic_coordinate_conversion#Coordinate_system_conversion\r\n    const latRad = MathUtils.degToRad(lat);\r\n    const lonRad = MathUtils.degToRad(lon);\r\n\r\n    const a = MODEL_RADIUS;\r\n    const eSquared = flattening * (2 - flattening);\r\n    const N = a / Math.sqrt(1 - eSquared * (Math.sin(latRad) ** 2));\r\n\r\n    const z = (N + height) * Math.cos(latRad) * Math.cos(lonRad);\r\n    const x = (N + height) * Math.cos(latRad) * Math.sin(lonRad);\r\n    const y = (N * (1 - eSquared) + height) * Math.sin(latRad);\r\n\r\n    return new THREE.Vector3(x, y, z);\r\n}\r\n\r\n/**\r\n * Returns the position of one endpoint of the geodetic coordinate line which lies on the equatorial plane.\r\n * @param lat Latitude, in degrees.\r\n * @param lon Longitude, in degrees.\r\n * @param flattening Flattening factor of the ellipsoid.\r\n * @returns {Vector3} The world position of this point.\r\n */\r\nexport function getGeodeticOrigin(lat, lon, flattening) {\r\n    const latRad = MathUtils.degToRad(lat);\r\n    const lonRad = MathUtils.degToRad(lon);\r\n\r\n    const a = MODEL_RADIUS;\r\n    const eSquared = flattening * (2 - flattening);\r\n    const N = a / Math.sqrt(1 - eSquared * (Math.sin(latRad) ** 2));\r\n\r\n    const z = eSquared * N * Math.cos(latRad) * Math.cos(lonRad);\r\n    const x = eSquared * N * Math.cos(latRad) * Math.sin(lonRad);\r\n\r\n    return new THREE.Vector3(x, 0, z);\r\n}","import * as THREE from \"three\";\r\nimport React, { useLayoutEffect, useRef } from \"react\";\r\nimport { MODEL_RADIUS } from \"../Constants\";\r\nimport { geocentricToWorld, geodeticToWorld, getGeodeticOrigin } from \"../CoordinateMath\";\r\n\r\n/**\r\n * Draws a line visualizing the given latitude and longitude as geocentric coordinates.\r\n */\r\nexport function GeocentricCoordinateLine({ latitude, longitude, lineColor }) {\r\n    return (\r\n        <MovingLine\r\n            start={new THREE.Vector3(0, 0, 0)}\r\n            end={geocentricToWorld(latitude, longitude, MODEL_RADIUS)}\r\n            lineColor={lineColor}\r\n\r\n            // Don't have this line cover the geodetic coordinate line\r\n            depthWrite={false}\r\n        />\r\n    );\r\n}\r\n\r\n/**\r\n * Draws a line visualizing the given latitude and longitude as geodetic coordinates.\r\n * (The flattening parametrizes the ellipsoid relative to which the geodetic coordinates are defined.)\r\n */\r\nexport function GeodeticCoordinateLine({latitude, longitude, flattening, lineColor}) {\r\n    return (\r\n        <MovingLine\r\n            start={getGeodeticOrigin(latitude, longitude, flattening)}\r\n            end={geodeticToWorld(latitude, longitude, flattening, MODEL_RADIUS)}\r\n            lineColor={lineColor}\r\n\r\n            renderOrder={2}\r\n            depthWrite={true}\r\n        />\r\n    );\r\n}\r\n\r\n/**\r\n * A line segment with dynamic endpoints.\r\n */\r\nfunction MovingLine(props) {\r\n    const bufferGeometryRef = useRef();\r\n\r\n    useLayoutEffect(() => {\r\n            const vertices = [\r\n                props.start,\r\n                props.end\r\n            ];\r\n            bufferGeometryRef.current.setFromPoints(vertices);\r\n        },\r\n        [props.start, props.end]\r\n    );\r\n\r\n    return (\r\n        <line\r\n            renderOrder={props.renderOrder ?? 0}\r\n        >\r\n            <bufferGeometry\r\n                attach=\"geometry\"\r\n                ref={bufferGeometryRef}\r\n            />\r\n            <lineBasicMaterial\r\n                attach=\"material\"\r\n                color={props.lineColor}\r\n                depthWrite={props.depthWrite}\r\n            />\r\n        </line>\r\n    );\r\n}\r\n","import { Html } from \"@react-three/drei\";\r\nimport React, { useEffect, useRef } from \"react\";\r\nimport \"./styles/geoid_height.css\";\r\n\r\nconst geoidHeightImageSrc = \"./geoid-height-grid.png\";\r\nconst geoidHeightCanvasId = \"geoid-height-grid\";\r\n\r\n/**\r\n * A hidden canvas containing a grid of geoid heights.\r\n * This canvas is used as a lookup table for the geoid height, so it must be included in the scene.\r\n */\r\nexport function GeoidHeightCanvas() {\r\n    const canvasRef = useRef();\r\n\r\n    useEffect(() => {\r\n        const image = new Image(361, 181);\r\n        image.src = geoidHeightImageSrc;\r\n\r\n        image.onload = () => {\r\n            console.log(\"Finished loading geoid height image.\");\r\n\r\n            const context = canvasRef.current.getContext(\"2d\");\r\n            context.drawImage( image, 0, 0 );\r\n        };\r\n    }, []);\r\n\r\n    return (\r\n        <Html>\r\n            <canvas\r\n                ref={canvasRef}\r\n                hidden\r\n                id={geoidHeightCanvasId}\r\n                width={361}\r\n                height={181}\r\n            />\r\n        </Html>\r\n    );\r\n}\r\n\r\n/**\r\n * Text overlaid on top of the scene, in the top center.\r\n */\r\nfunction CenteredText({ text }) {\r\n    return (\r\n        <Html\r\n            transform={false}\r\n            zIndexRange={[0, 0]}\r\n            className=\"geoid-height-label\"\r\n            style={{\r\n                \"position\": \"relative\",\r\n                \"left\": \"-50%\",\r\n            }}\r\n            calculatePosition={(el, camera, size) => [size.width / 2, 0]}\r\n        >\r\n            <p>\r\n                {text}\r\n            </p>\r\n        </Html>\r\n    )\r\n}\r\n\r\n/**\r\n * Displays the geoid height at the given latitude and longitude.\r\n */\r\nexport function GeoidHeightDisplay({ latitude, longitude }) {\r\n    const canvas = document.getElementById(geoidHeightCanvasId);\r\n\r\n    const context = canvas.getContext(\"2d\");\r\n    const geoidHeight = lookupGeoidHeight(context, latitude, longitude);\r\n\r\n    return (\r\n        <CenteredText\r\n            text = {`Geoid height: ${geoidHeight} m`}\r\n        />\r\n    );\r\n}\r\n\r\n/**\r\n * Finds the geoid height at the given coordinates.\r\n * @param context The 2d context of the canvas where the lookup image is stored.\r\n * @param lat Latitude, in degrees.\r\n * @param lon Longitude, in degrees.\r\n * @returns {number} The geoid height, in meters, rounded to the nearest integer.\r\n */\r\nfunction lookupGeoidHeight( context, lat, lon ) {\r\n    const [ imgX, imgY ] = getImgXYFromCoordinates(lon, lat);\r\n\r\n    const data = context.getImageData(imgX, imgY, 1, 1).data;\r\n\r\n    return pixelToGeoidHeight(data[0]);\r\n}\r\n\r\nfunction getImgXYFromCoordinates(lon, lat) {\r\n    return [lon + 180 , 90 - lat]\r\n}\r\n\r\n/**\r\n * Decodes the rounded geoid height from the stored pixel value.\r\n *\r\n * The geoid heights were stored according to a linear scale, where pixel=0 corresponds to the minimum geoid height\r\n * in the dataset, and pixel=255 corresponds to the maximum.\r\n * @param pixelValue The value of the pixel in the lookup image. Should be an integer in [0, 255].\r\n * @returns {number} The geoid height, in meters, rounded to the nearest integer.\r\n */\r\nfunction pixelToGeoidHeight(pixelValue) {\r\n    const maxHeight = 78.21;\r\n    const minHeight = -106.57;\r\n\r\n    const height = minHeight + pixelValue / 255 * (maxHeight - minHeight);\r\n\r\n    return Math.round(height);\r\n}","import React, { useRef, useState } from \"react\";\r\nimport { useFrame } from \"@react-three/fiber\";\r\nimport { MODEL_RADIUS } from \"../Constants\";\r\n\r\n/**\r\n * The color of a {@link SpherePoint} when not hovered over.\r\n * @type {string}\r\n */\r\nconst NORMAL_COLOR = \"#00ffbb\";\r\n\r\n/**\r\n * The color of a {@link SpherePoint} when hovered over.\r\n * @type {string}\r\n */\r\nconst HOVER_COLOR = \"#ff0090\";\r\n\r\n/**\r\n * A small spherical point that can be placed at a given world position in the scene.\r\n * Changes color when hovered over.\r\n */\r\nexport function SpherePoint({ position }) {\r\n    const materialRef = useRef();\r\n    const [hover, setHover] = useState(false);\r\n\r\n    useFrame(() => {\r\n        materialRef.current.color.set(hover ? HOVER_COLOR : NORMAL_COLOR);\r\n    });\r\n\r\n    return (\r\n        <mesh\r\n            position={position}\r\n\r\n            onPointerOver={() => setHover(true)}\r\n            onPointerOut={() => setHover(false)}\r\n        >\r\n            <sphereBufferGeometry\r\n                attach=\"geometry\"\r\n                args={[MODEL_RADIUS / 80, 10, 5]}\r\n            />\r\n            <meshStandardMaterial\r\n                attach=\"material\"\r\n                ref={materialRef}\r\n                color={NORMAL_COLOR}\r\n            />\r\n        </mesh>\r\n    );\r\n}","import React, { useMemo } from \"react\";\r\nimport * as THREE from \"three\";\r\nimport { SpherePoint } from \"./SpherePoint\";\r\nimport { MODEL_LAYER, MODEL_RADIUS } from \"../Constants\";\r\nimport { geocentricEllipsoidIntersection, geocentricToWorld, geodeticToWorld, } from \"../CoordinateMath\";\r\nimport { useThree } from \"@react-three/fiber\";\r\n\r\n/**\r\n * Draws the point on the sphere given by the geocentric latitude and longitude.\r\n */\r\nexport function SphereIntersection( {latitude, longitude} ) {\r\n    return (\r\n        <SpherePoint\r\n            position={geocentricToWorld(latitude, longitude, 0)}\r\n        />\r\n    );\r\n}\r\n\r\n/**\r\n * Draws the point on the ellipsoid given by the geocentric latitude and longitude.\r\n */\r\nexport function GeocentricEllipsoidIntersection({latitude, longitude, flattening} ) {\r\n    return (\r\n        <SpherePoint\r\n            position={geocentricEllipsoidIntersection(latitude, longitude, flattening)}\r\n        />\r\n    );\r\n}\r\n\r\n/**\r\n * Draws the point on the ellipsoid given by the geodetic latitude and longitude.\r\n */\r\nexport function GeodeticEllipsoidIntersection({latitude, longitude, flattening}) {\r\n    return (\r\n        <SpherePoint\r\n            position={geodeticToWorld(latitude, longitude, flattening, 0)}\r\n        />\r\n    );\r\n}\r\n\r\n/**\r\n * Draws a point on the specified model that corresponds to the given geocentric latitude and longitude.\r\n *\r\n * Uses the first model in MODEL_LAYER whose .name equals the given name.\r\n */\r\nexport function GeocentricRaycastIntersectionByName({ latitude, longitude, objectName } ) {\r\n    const rayStart = geocentricToWorld(latitude, longitude, MODEL_RADIUS);\r\n\r\n    return (\r\n        <RaycastIntersectionByName\r\n            rayStart={rayStart}\r\n            direction={rayStart.clone().negate()}\r\n            objectName={objectName}\r\n        />\r\n    );\r\n}\r\n\r\n/**\r\n * Draws a point on the specified model that corresponds to the geodetic latitude and longitude.\r\n *\r\n * Uses the first model in MODEL_LAYER whose .name equals the given name.\r\n */\r\nexport function GeodeticRaycastIntersectionByName({ latitude, longitude, flattening, objectName }) {\r\n    const rayStart = geodeticToWorld(latitude, longitude, flattening, MODEL_RADIUS);\r\n    const direction = geodeticToWorld(latitude, longitude, flattening, -MODEL_RADIUS / 2).sub(rayStart);\r\n\r\n    return (\r\n        <RaycastIntersectionByName\r\n            rayStart={rayStart}\r\n            direction={direction}\r\n            objectName={objectName}\r\n        />\r\n    );\r\n}\r\n\r\n/**\r\n * Draws a point on the given object that corresponds to the geocentric latitude and longitude.\r\n */\r\nexport function GeocentricRaycastIntersectionByObject({ latitude, longitude, object }) {\r\n    const rayStart = geocentricToWorld(latitude, longitude, MODEL_RADIUS);\r\n\r\n    return (\r\n        <RaycastIntersectionByObject\r\n            rayStart={rayStart}\r\n            direction={rayStart.clone().negate()}\r\n            object={object}\r\n        />\r\n    );\r\n}\r\n\r\n/**\r\n * Draws a point on the given object that corresponds to the geodetic latitude and longitude.\r\n */\r\nexport function GeodeticRaycastIntersectionByObject({ latitude, longitude, flattening, object }) {\r\n    const rayStart = geodeticToWorld(latitude, longitude, flattening, MODEL_RADIUS);\r\n    const direction = geodeticToWorld(latitude, longitude, flattening, -MODEL_RADIUS / 2).sub(rayStart);\r\n\r\n    return (\r\n        <RaycastIntersectionByObject\r\n            rayStart={rayStart}\r\n            direction={direction}\r\n            object={object}\r\n        />\r\n    );\r\n}\r\n\r\n/**\r\n * Raycasts against an object and draws the first intersection it finds (or nothing, if no intersection).\r\n * The raycasting uses the layer MODEL_LAYER.\r\n * @param rayStart Start position of the ray (Vector3).\r\n * @param direction Direction to raycast in (Vector3). Can be any length, the function will normalize it.\r\n * @param object The Object3D to intersect.\r\n */\r\nfunction RaycastIntersectionByObject({rayStart, direction, object}) {\r\n    const raycaster = useMemo(() => {\r\n        const r = new THREE.Raycaster();\r\n        r.layers.set(MODEL_LAYER);\r\n\r\n        return r;\r\n    }, []);\r\n\r\n    if (object) {\r\n        raycaster.set(rayStart, direction.normalize());\r\n\r\n        const intersections = raycaster.intersectObject(object);\r\n\r\n        console.log(\"Performed a raycast: \");\r\n        console.log(intersections[0]);\r\n\r\n        if (intersections[0]) {\r\n            return (\r\n                <SpherePoint\r\n                    position={intersections[0].point}\r\n                />\r\n            );\r\n        }\r\n    }\r\n\r\n    return null;\r\n}\r\n\r\n/**\r\n * Raycasts against the whole scene and finds the first intersection with an object that has the given name.\r\n * The raycasting uses the layer MODEL_LAYER.\r\n * @param rayStart Start position of the ray (Vector3).\r\n * @param direction Direction to raycast in (Vector3). Can be any length, the function will normalize it.\r\n * @param objectName The Object3D to intersect.\r\n */\r\nfunction RaycastIntersectionByName({rayStart, direction, objectName}) {\r\n    const { scene } = useThree();\r\n\r\n    const raycaster = useMemo(() => {\r\n        const r = new THREE.Raycaster();\r\n        r.layers.set(MODEL_LAYER);\r\n\r\n        return r;\r\n    }, []);\r\n\r\n    raycaster.set(rayStart, direction.normalize());\r\n\r\n    const intersections = raycaster.intersectObjects(scene.children, true);\r\n    const modelIntersection = intersections.find((intersection) => intersection.object.name === objectName);\r\n\r\n    console.log(\"Performed a raycast: \");\r\n    console.log(modelIntersection);\r\n\r\n    if (modelIntersection) {\r\n        return (\r\n            <SpherePoint\r\n                position={modelIntersection.point}\r\n            />\r\n        );\r\n    }\r\n\r\n    return null;\r\n}","import { Html } from \"@react-three/drei\";\r\nimport \"./styles/legend.css\";\r\n\r\n/**\r\n * Takes 2 legend elements and groups them with the proper position and alignment.\r\n */\r\nexport function LegendWrapper({gradientLegend, elementsLegend}) {\r\n    return (\r\n        <Html\r\n            calculatePosition={(el, camera, size) => {\r\n                return [0, size.height];\r\n            }}\r\n            prepend\r\n            zIndexRange={[0, 0]}\r\n            className=\"legends-root\"\r\n        >\r\n            <div className=\"legends-wrapper\">\r\n                {elementsLegend}\r\n                {gradientLegend}\r\n            </div>\r\n        </Html>\r\n    )\r\n}\r\n\r\n/**\r\n * Legend for the colour gradient on the geoid.\r\n * @param top Label for the maximum value.\r\n * @param middle Label for the middle value.\r\n * @param bottom Label for the minimum value.\r\n */\r\nexport function GradientLegend({top, middle, bottom}) {\r\n    return (\r\n        <div className=\"gradient-legend-wrapper\">\r\n            <img\r\n                id=\"horizontal-gradient\"\r\n                src={\"geoid-gradient-legend-horizontal.png\"}\r\n                alt={\"geoid gradient legend\"}\r\n            />\r\n            <img\r\n                id=\"vertical-gradient\"\r\n                src={\"geoid-gradient-legend-vertical.png\"}\r\n                alt={\"geoid gradient legend\"}\r\n            />\r\n\r\n            <div className=\"gradient-labels-wrapper\">\r\n                <div className=\"legend-text\">\r\n                    {top}\r\n                </div>\r\n                <div className=\"legend-text\">\r\n                    {middle}\r\n                </div>\r\n                <div className=\"legend-text\">\r\n                    {bottom}\r\n                </div>\r\n            </div>\r\n        </div>\r\n    );\r\n}\r\n\r\n/**\r\n * Legend for the different objects in the visualization.\r\n * @param elements Items to show in the legend. Items should have structure\r\n * {\r\n *      label: <the item's label>,\r\n *      block: <the item's symbol; use a ___Block component>,\r\n * }\r\n */\r\nexport function Legend({elements}) {\r\n    return (\r\n        <ul className=\"list-legend-wrapper\">\r\n            {Object.keys(elements).map((label) => (\r\n                <LegendElement key={label}\r\n                               block={elements[label]}\r\n                               label={label} />\r\n            ))}\r\n        </ul>\r\n    );\r\n}\r\n\r\nfunction LegendElement({ block, label }) {\r\n    return (\r\n        <li className=\"legend-item-wrapper\">\r\n            {block}\r\n            <span className=\"legend-text legend-value\">\r\n                {label}\r\n            </span>\r\n        </li>\r\n    );\r\n}\r\n\r\n/**\r\n * Legend symbol of a line with the given colour.\r\n */\r\nexport function LineBlock({ color }) {\r\n    return (\r\n        <span className=\"legend-key\">\r\n            <hr\r\n                style={{\r\n                    borderWidth: \"1px 0 0 0\",\r\n                    borderStyle: \"solid\",\r\n                    borderColor: color,\r\n                }}\r\n            />\r\n        </span>\r\n    );\r\n}\r\n\r\n/**\r\n * Legend symbol from an image.\r\n */\r\nexport function ImageBlock({ src, alt }) {\r\n    return (\r\n        <img\r\n            className=\"legend-key\"\r\n            src={src}\r\n            alt={alt}\r\n        />\r\n    );\r\n}\r\n\r\n/**\r\n * Legend symbol for a colour.\r\n */\r\nexport function ColorBlock({ color }) {\r\n    return (\r\n        <span\r\n            className=\"legend-key\"\r\n            style={{\r\n                backgroundColor: color ?? \"white\",\r\n            }}\r\n        />\r\n    );\r\n}","import { buttonGroup, folder, useControls } from \"leva\";\r\nimport React, { useEffect } from \"react\";\r\nimport { Geoid } from \"./Geoid\";\r\nimport { Ellipsoid, Sphere } from \"./Spheroids\";\r\nimport { GeocentricCoordinateLine, GeodeticCoordinateLine } from \"./CoordinateLine\";\r\nimport { GeoidHeightCanvas, GeoidHeightDisplay } from \"./GeoidHeightDisplay\";\r\nimport {\r\n    GeocentricEllipsoidIntersection,\r\n    GeocentricRaycastIntersectionByName,\r\n    GeodeticEllipsoidIntersection,\r\n    GeodeticRaycastIntersectionByName,\r\n    SphereIntersection\r\n} from \"./Intersections\";\r\nimport {\r\n    COORDINATES_FOLDER,\r\n    ELLIPSOID_COLOR,\r\n    ELLIPSOID_CONTROL_HINT,\r\n    FLATTENING_CONTROL_HINT,\r\n    GEOCENTRIC_CONTROL_HINT,\r\n    GEOCENTRIC_LINE_COLOR,\r\n    GEODETIC_CONTROL_HINT,\r\n    GEODETIC_LINE_COLOR,\r\n    GEOID_CONTROL,\r\n    GEOID_CONTROL_HINT,\r\n    GEOID_HEIGHT_CONTROL,\r\n    GEOID_NAME,\r\n    GRATICULE_COLOR,\r\n    LATITUDE_CONTROL_HINT,\r\n    LONGITUDE_CONTROL_HINT,\r\n    MODEL_RADIUS,\r\n    MODELS_FOLDER,\r\n    SPHERE_COLOR,\r\n    SPHERE_CONTROL_HINT,\r\n    WGS_FLATTENING\r\n} from \"../Constants\";\r\nimport { ColorBlock, GradientLegend, ImageBlock, Legend, LegendWrapper, LineBlock } from \"./Legend\";\r\n\r\n/**\r\n * Renders the main content of the visualization, including coordinate lines, models, etc.\r\n */\r\nexport function Visualization() {\r\n    const {latitude, longitude} = useControls(COORDINATES_FOLDER, {\r\n        latitude: {\r\n            value: 0,\r\n            min: -90,\r\n            max: 90,\r\n            step: 1,\r\n            hint: LATITUDE_CONTROL_HINT,\r\n        },\r\n        longitude: {\r\n            value: 0,\r\n            min: -180,\r\n            max: 180,\r\n            step: 1,\r\n            hint: LONGITUDE_CONTROL_HINT,\r\n        }\r\n    });\r\n\r\n    const [{ [GEOID_HEIGHT_CONTROL]: geoidHeightMode, geodetic, geocentric }, set] = useControls(() => ({\r\n        [MODELS_FOLDER]: folder(\r\n            {\r\n                [GEOID_HEIGHT_CONTROL]: {\r\n                    value: false,\r\n                    render: () => false,\r\n                },\r\n                \"geoid height\": buttonGroup({\r\n                    \"on\": () => set({\r\n                        [GEOID_HEIGHT_CONTROL]: true,\r\n                        geodetic: true,\r\n                        geocentric: false,\r\n                    }),\r\n                    \"off\": () => set({\r\n                        [GEOID_HEIGHT_CONTROL]: false,\r\n                    }),\r\n                }),\r\n            }\r\n        ),\r\n        [COORDINATES_FOLDER]: folder(\r\n            {\r\n                geodetic: {\r\n                    value: true,\r\n                    render: (get) => !get(`${MODELS_FOLDER}.${GEOID_HEIGHT_CONTROL}`),\r\n                    hint: GEODETIC_CONTROL_HINT,\r\n                },\r\n                geocentric: {\r\n                    value: false,\r\n                    render: (get) => !get(`${MODELS_FOLDER}.${GEOID_HEIGHT_CONTROL}`),\r\n                    hint: GEOCENTRIC_CONTROL_HINT,\r\n                },\r\n            }\r\n        ),\r\n    }));\r\n\r\n    return (\r\n        <>\r\n            <GeoidHeightCanvas/>\r\n            <Models\r\n                latitude={latitude}\r\n                longitude={longitude}\r\n                geoidHeightMode={geoidHeightMode}\r\n                geodetic={geodetic}\r\n                geocentric={geocentric}\r\n            />\r\n            {\r\n                geoidHeightMode ?\r\n                <GeoidHeightDisplay\r\n                    latitude={latitude}\r\n                    longitude={longitude}\r\n                /> : null\r\n            }\r\n        </>\r\n    );\r\n}\r\n\r\nfunction Models({ latitude, longitude, geoidHeightMode, geocentric, geodetic }) {\r\n    const [ { sphere, ellipsoid, flattening }, set ] = useControls(MODELS_FOLDER, () => ({\r\n        sphere: {\r\n            value: 0,\r\n            min: 0,\r\n            max: 1,\r\n            render: (get) => !get(`${MODELS_FOLDER}.${GEOID_HEIGHT_CONTROL}`),\r\n            hint: SPHERE_CONTROL_HINT,\r\n        },\r\n        ellipsoid: {\r\n            value: 0,\r\n            min: 0,\r\n            max: 1,\r\n            hint: ELLIPSOID_CONTROL_HINT,\r\n        },\r\n        flattening: {\r\n            value: 0.15,\r\n            min: 0,\r\n            max: 1,\r\n            render: (get) => !get(`${MODELS_FOLDER}.${GEOID_HEIGHT_CONTROL}`),\r\n            hint: FLATTENING_CONTROL_HINT,\r\n        },\r\n    }));\r\n\r\n    const [{ [GEOID_CONTROL] : geoid }, setGeoid] = useControls(MODELS_FOLDER, () => ({\r\n        [GEOID_CONTROL]: {\r\n            value: true,\r\n            render: (get) => !get(`${MODELS_FOLDER}.${GEOID_HEIGHT_CONTROL}`),\r\n            hint: GEOID_CONTROL_HINT,\r\n            onChange: (value) => {\r\n                if (value) {\r\n                    set({\r\n                        sphere: 0,\r\n                        ellipsoid: 0,\r\n                    });\r\n                }\r\n            },\r\n            transient: false,\r\n        },\r\n    }));\r\n\r\n    // When the geoid height view is turned on, makes the geoid visible.\r\n    useEffect(() => {\r\n        if (geoidHeightMode) {\r\n            setGeoid({ [GEOID_CONTROL]: true });\r\n        }\r\n    }, [geoidHeightMode, setGeoid]);\r\n\r\n    // When the geoid height view is turned on, hides the sphere and sets a default flattening.\r\n    useEffect(() => {\r\n        if (geoidHeightMode) {\r\n            set({\r\n                sphere: 0,\r\n                flattening: WGS_FLATTENING,\r\n            });\r\n        }\r\n    }, [geoidHeightMode, set]);\r\n\r\n    // When sphere is fully opaque, decreases the sphere opacity so it is clear that the ellipsoid is behind it.\r\n    useEffect(() => {\r\n        if (sphere === 1) {\r\n            set({ sphere: 0.5 });\r\n        }\r\n    }, [ellipsoid, flattening, set]);\r\n\r\n    const gradientLegend = (\r\n        geoid ?\r\n            <GradientLegend top={\"78 m\"} middle={\"Ellipsoid\"} bottom={\"-106 m\"}/>\r\n            : null\r\n    );\r\n\r\n    const legend = <Legend elements={getLegendElements(sphere > 0, ellipsoid > 0, geoid, geocentric, geodetic)}/>;\r\n\r\n    return (\r\n        <>\r\n            <Ellipsoid\r\n                opacity={ellipsoid}\r\n                flattening={flattening}\r\n                color={ELLIPSOID_COLOR}\r\n                edgeColor={GRATICULE_COLOR}\r\n                radius={MODEL_RADIUS}\r\n            />\r\n            <Sphere\r\n                opacity={sphere}\r\n                color={SPHERE_COLOR}\r\n                edgeColor={GRATICULE_COLOR}\r\n                radius={MODEL_RADIUS}\r\n            />\r\n            {\r\n                geocentric ? (\r\n                    <GeocentricCoordinateLine\r\n                        latitude={latitude}\r\n                        longitude={longitude}\r\n                        lineColor={GEOCENTRIC_LINE_COLOR}\r\n                    />\r\n                ) : null\r\n            }\r\n            {\r\n                geodetic ? (\r\n                    <GeodeticCoordinateLine\r\n                        latitude={latitude}\r\n                        longitude={longitude}\r\n                        flattening={flattening}\r\n                        lineColor={GEODETIC_LINE_COLOR}\r\n                    />\r\n                ) : null\r\n            }\r\n            {\r\n                geocentric && (sphere > 0) ? (\r\n                    <SphereIntersection\r\n                        latitude={latitude}\r\n                        longitude={longitude}\r\n                    />\r\n                ) : null\r\n            }\r\n            {\r\n                geodetic && (ellipsoid > 0) ? (\r\n                    <GeodeticEllipsoidIntersection\r\n                        latitude={latitude}\r\n                        longitude={longitude}\r\n                        flattening={flattening}\r\n                    />\r\n                ) : null\r\n            }\r\n            {\r\n                geocentric && (ellipsoid > 0) ? (\r\n                    <GeocentricEllipsoidIntersection\r\n                        latitude={latitude}\r\n                        longitude={longitude}\r\n                        flattening={flattening}\r\n                    />\r\n                ) : null\r\n            }\r\n            <Geoid\r\n                isVisible={geoid}\r\n            />\r\n            {\r\n                geoid && geocentric ? (\r\n                    <GeocentricRaycastIntersectionByName\r\n                        latitude={latitude}\r\n                        longitude={longitude}\r\n                        objectName={GEOID_NAME}\r\n                    />\r\n                ) : null\r\n            }\r\n            {\r\n                geoid && geodetic ? (\r\n                    <GeodeticRaycastIntersectionByName\r\n                        latitude={latitude}\r\n                        longitude={longitude}\r\n                        flattening={flattening}\r\n                        objectName={GEOID_NAME}\r\n                    />\r\n                ) : null\r\n            }\r\n            <LegendWrapper gradientLegend={gradientLegend} elementsLegend={legend}/>\r\n        </>\r\n    );\r\n}\r\n\r\nfunction getLegendElements(sphere, ellipsoid, geoid, geocentric, geodetic) {\r\n    const elements = {};\r\n\r\n    if (geoid) {\r\n        elements[\"Geoid\"] = <ImageBlock src={\"geoid-gradient.png\"} alt={\"A legend for the geoid colour gradient\"}/>;\r\n    }\r\n\r\n    if (ellipsoid) {\r\n        elements[\"Ellipsoid\"] = <ColorBlock color={ELLIPSOID_COLOR}/>;\r\n    }\r\n\r\n    if (sphere) {\r\n        elements[\"Sphere\"] = <ColorBlock color={SPHERE_COLOR}/>;\r\n    }\r\n\r\n    if (geodetic) {\r\n        elements[\"Geodetic\"] = <LineBlock color={GEODETIC_LINE_COLOR}/>;\r\n    }\r\n\r\n    if (geocentric) {\r\n        elements[\"Geocentric\"] = <LineBlock color={GEOCENTRIC_LINE_COLOR}/>;\r\n    }\r\n\r\n    return elements;\r\n}","import React from 'react'\r\nimport { Canvas } from '@react-three/fiber'\r\nimport './styles.css'\r\nimport {\r\n    CameraAlignedLight,\r\n    FreeControlsWithClickDetection, SetCameraLayers,\r\n} from \"./Components/ControlsAndLight\";\r\nimport { Visualization } from \"./Components/Visualization\";\r\nimport { Stats } from \"@react-three/drei\";\r\nimport { Leva } from 'leva';\r\nimport { MODEL_RADIUS } from \"./Constants\";\r\n\r\nfunction App() {\r\n    return (\r\n        <>\r\n            <Canvas\r\n                camera={{\r\n                    position: [MODEL_RADIUS * 2 + 0.5, 0, 0]\r\n                }}\r\n            >\r\n                <SetCameraLayers/>\r\n                <ambientLight intensity={0.15}/>\r\n\r\n                <Visualization/>\r\n\r\n                <CameraAlignedLight/>\r\n                <FreeControlsWithClickDetection/>\r\n\r\n                <Stats />\r\n            </Canvas>\r\n            <Leva hideCopyButton={true} />\r\n        </>\r\n    );\r\n}\r\n\r\nexport default App;\r\n","import React from 'react';\r\nimport ReactDOM from 'react-dom';\r\nimport App from './App';\r\n\r\nReactDOM.render(\r\n    <App />,\r\n  document.getElementById('root')\r\n);\r\n"],"sourceRoot":""}