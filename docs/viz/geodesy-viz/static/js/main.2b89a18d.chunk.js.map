{"version":3,"sources":["Constants.js","Components/ControlsAndLight.js","Components/Loading.js","Components/Geoid.js","Components/Spheroids.js","CoordinateMath.js","Components/CoordinateLine.js","Components/GeoidHeightDisplay.js","Components/SpherePoint.js","Components/Intersections.js","Components/Legend.js","Components/Visualization.js","Components/LinkBack.js","App.js","index.js"],"names":["GRATICULE_COLOR","ELLIPSOID_COLOR","SPHERE_COLOR","GEOCENTRIC_LINE_COLOR","GEODETIC_LINE_COLOR","GEOID_HEIGHT_CONTROL","GEOID_CONTROL","MODELS_FOLDER","COORDINATES_FOLDER","GEOID_NAME","SetCameraLayers","camera","useThree","useEffect","layers","enable","FreeControlsWithClickDetection","useControls","autoRotate","value","hint","set","window","addEventListener","console","log","FreeControls","gl","controls","useRef","useFrame","current","update","OrbitControls","ref","args","minDistance","MODEL_RADIUS","maxDistance","enablePan","autoRotateSpeed","CameraAlignedLight","light","matrixAutoUpdate","intensity","min","max","followCamera","offset","step","collapsed","matrix","copy","cameraMatrix","offsetDegrees","frameMatrix","clone","setPosition","frameMatrixInv","invert","rotationMatrix","THREE","makeRotationY","MathUtils","degToRad","multiply","calculateLightMatrix","matrixWorld","LoadingScreen","Html","transform","fullscreen","className","GEOID_MODEL_PATH","Geoid","isVisible","onGeoidLoad","fallback","GeoidModel","useGLTF","nodes","materials","dispose","geometry","Sphere","material","GeoidFlatMaterial","name","scale","visible","preload","props","ScaledSphere","Ellipsoid","flattening","semimajorAxis","sphereGeometry","useMemo","SphereBufferGeometry","radius","WIDTH_SEGMENTS","opacity","attach","color","transparent","edgeColor","depthWrite","geocentricEllipsoidIntersection","lat","lon","latRad","lonRad","z","Math","cos","x","sin","y","R","sqrt","multiplyScalar","geocentricToWorld","height","longitudeDeg","latitudeDeg","theta","phi","setFromSphericalCoords","geodeticToWorld","eSquared","N","getGeodeticOrigin","GeocentricCoordinateLine","latitude","longitude","lineColor","MovingLine","start","end","GeodeticCoordinateLine","renderOrder","bufferGeometryRef","useLayoutEffect","vertices","setFromPoints","geoidHeightCanvasId","GeoidHeightCanvas","canvasRef","image","Image","src","onload","getContext","drawImage","hidden","id","width","CenteredText","text","zIndexRange","style","calculatePosition","el","size","GeoidHeightDisplay","geoidHeight","context","getImgXYFromCoordinates","imgX","imgY","pixelValue","minHeight","round","pixelToGeoidHeight","getImageData","data","lookupGeoidHeight","document","getElementById","NORMAL_COLOR","SpherePoint","position","materialRef","useState","hover","setHover","onPointerOver","onPointerOut","SphereIntersection","GeocentricEllipsoidIntersection","GeodeticEllipsoidIntersection","raycast","scene","raycaster","rayStart","direction","objectName","normalize","intersection","intersectObjects","children","find","object","point","LegendWrapper","gradientLegend","elementsLegend","prepend","GradientLegend","top","middle","bottom","alt","Legend","elements","Object","keys","map","label","LegendElement","block","LineBlock","borderWidth","borderStyle","borderColor","ImageBlock","ColorBlock","backgroundColor","Visualization","folder","render","buttonGroup","geodetic","get","geocentric","geoidHeightMode","Models","sphere","ellipsoid","setModels","onChange","transient","geoid","setGeoid","r","shouldUpdate","setShouldUpdate","geodeticIntersection","setGeodeticIntersection","geocentricIntersection","setGeocentricIntersection","sub","geodeticRaycast","negate","geocentricRaycast","legend","getLegendElements","LinkBack","url","href","target","rel","App","Stats","hideCopyButton","ReactDOM"],"mappings":"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","file":"static/js/main.2b89a18d.chunk.js","sourcesContent":["/**\n * Colors of the objects in the visualization.\n */\nexport const GRATICULE_COLOR = \"#ffffff\";\nexport const ELLIPSOID_COLOR = \"#5e78ce\";\nexport const SPHERE_COLOR = \"#d074b3\";\nexport const GEOCENTRIC_LINE_COLOR = \"#0047fd\";\nexport const GEODETIC_LINE_COLOR = \"#d30000\";\n\n/**\n * This value determines the size of the three models. In the sphere/ellipsoid case, it is used to specify the radius of\n * the geometry (before scaling).\n */\nexport const MODEL_RADIUS = 1;\n\n/**\n * The layer the models are placed into for more efficient raycasting.\n */\nexport const MODEL_LAYER = 5;\n\n/**\n * Constant flattening factor of the WGS84 ellipsoid.\n */\nexport const WGS_FLATTENING = 1 / 298.257223560;\n\nexport const VANCOUVER_LATITUDE = 49;\nexport const VANCOUVER_LONGITUDE = -122;\n\n/**\n * Name of the control that controls the geoid height view.\n */\nexport const GEOID_HEIGHT_CONTROL = \"geoidHeight\";\n\n/**\n * Displayed name of the Leva control that shows/hides the geoid.\n */\nexport const GEOID_CONTROL = \"show geoid?\";\n\n/**\n * Names of the Leva folders for models and coordinates.\n */\nexport const MODELS_FOLDER = \"Models\";\nexport const COORDINATES_FOLDER = \"Coordinates\";\n\n/**\n * Tooltip text for the Leva controls.\n */\nexport const GEOID_CONTROL_HINT = \"Show/hide the geoid\";\nexport const SPHERE_CONTROL_HINT = \"Visibility of the sphere\";\nexport const ELLIPSOID_CONTROL_HINT = \"Visibility of the ellipsoid\";\nexport const FLATTENING_CONTROL_HINT = \"Flattening factor of the ellipsoid\";\n\nexport const LATITUDE_CONTROL_HINT = \"Latitude (degrees)\";\nexport const LONGITUDE_CONTROL_HINT = \"Longitude (degrees)\";\nexport const GEODETIC_CONTROL_HINT = \"Show as geodetic coordinates\";\nexport const GEOCENTRIC_CONTROL_HINT = \"Show as geocentric coordinates\";\n\nexport const AUTOROTATE_HINT = \"Automatically rotate around models\";\n\nexport const LIGHT_INTENSITY_HINT = \"Light intensity\";\nexport const LIGHT_FOLLOW_HINT = \"Make the light rotate with you\";\nexport const LIGHT_OFFSET_HINT = \"Lighting angle, in degrees\";\n\n/**\n * Number of width and height segments of the sphere and ellipsoid.\n */\nexport const WIDTH_SEGMENTS = 48;\nexport const HEIGHT_SEGMENTS = WIDTH_SEGMENTS / 2;\n\n/**\n * The name associated with the geoid model object (used to identify the geoid).\n */\nexport const GEOID_NAME = \"geoid\";\n\nexport const LEGEND_GEOID = \"Geoid\";\nexport const LEGEND_ELLIPSOID = \"Ellipsoid\";\nexport const LEGEND_SPHERE = \"Sphere\";\nexport const LEGEND_GEODETIC = \"Geodetic (λ,ϕ)\";\nexport const LEGEND_GEOCENTRIC = \"Geocentric (λ,ϕ)\";","import { useFrame, useThree } from \"@react-three/fiber\";\nimport React, { useEffect, useRef } from \"react\";\nimport { OrbitControls } from \"@react-three/drei\";\nimport * as THREE from \"three\";\nimport { MathUtils } from \"three\";\nimport { useControls } from \"leva\";\nimport {\n    AUTOROTATE_HINT,\n    LIGHT_FOLLOW_HINT,\n    LIGHT_INTENSITY_HINT,\n    LIGHT_OFFSET_HINT,\n    MODEL_LAYER,\n    MODEL_RADIUS\n} from \"../Constants\";\n\n/**\n * Extends the default camera layers to include the layer we moved all models into.\n * This is required because we placed the primary models (sphere, ellipsoid, geoid) in a different layer to raycast\n * against them.\n */\nexport function SetCameraLayers() {\n    const { camera } = useThree();\n\n    useEffect(() => {\n        camera.layers.enable(MODEL_LAYER);\n    }, [camera.layers]);\n\n    return null;\n}\n\n/**\n * OrbitControls with some predefined camera settings, including auto-rotation and disabling panning.\n * Auto-rotation is initially on, and the first click turns it off.\n *\n * Adds the Camera folder to the Leva controls to toggle the auto-rotation.\n */\nexport function FreeControlsWithClickDetection() {\n    const [{ autoRotate }, set] = useControls(\"Camera\", () => ({\n        autoRotate: {\n            value: true,\n            hint: AUTOROTATE_HINT,\n        },\n    }));\n\n    useEffect(() => {\n        const stopRotating = () => {\n            console.log(\"Turning off auto rotation\");\n            set({ autoRotate: false });\n        };\n\n        window.addEventListener(\"click\", stopRotating, {\"once\": true});\n    }, [set]);\n\n    return (\n        <FreeControls autoRotate={autoRotate}/>\n    );\n}\n\nfunction FreeControls({ autoRotate }) {\n    const { camera, gl } = useThree();\n    const controls = useRef();\n\n    useFrame(() => {\n        controls.current.update();\n    });\n\n    return (\n        <OrbitControls\n            ref={controls}\n            args={[camera, gl]}\n            minDistance={MODEL_RADIUS + 0.5}\n            maxDistance={MODEL_RADIUS * 10}\n\n            enablePan={false}\n\n            autoRotate={autoRotate}\n            autoRotateSpeed={0.5}\n        />\n    );\n}\n\n/**\n * A directional light that shines from a fixed angle relative to the camera.\n *\n * Adds the Lighting folder to the Leva controls.\n */\nexport function CameraAlignedLight() {\n\n    const light = useRef();\n    useEffect(() => {\n        light.current.matrixAutoUpdate = false;\n    }, []);\n\n    const { camera } = useThree();\n\n    const { intensity, followCamera, offset } = useControls(\"Lighting\", {\n        intensity: {\n            value: 0.75,\n            min: 0,\n            max: 2,\n            hint: LIGHT_INTENSITY_HINT,\n        },\n        followCamera: {\n            value: true,\n            hint: LIGHT_FOLLOW_HINT,\n        },\n        offset: {\n            value: -65,\n            min: -180,\n            max: 180,\n            step: 1,\n            hint: LIGHT_OFFSET_HINT,\n        }\n    }, {\n        collapsed: true\n    });\n\n    useFrame(() => {\n        if (followCamera) {\n            light.current.matrix.copy(calculateLightMatrix(camera.matrixWorld, offset));\n        }\n    });\n\n    return (\n        <directionalLight\n            ref={light}\n            intensity={intensity}\n        />\n    );\n}\n\n/**\n * Calculates a transformation matrix for the light such that it shines from a fixed offset angle from the camera.\n *\n * Creates the illusion of rotating the models, when the user is actually rotating the camera.\n *\n * @param cameraMatrix The camera matrix (matrix that transforms positions in the camera frame to the world frame).\n * @param offsetDegrees The angle, in degrees, to offset the light by. A number in [-180, 180].\n * @returns {*} The .matrix of the light.\n */\nfunction calculateLightMatrix(cameraMatrix, offsetDegrees) {\n    /*\n    Get a frame f that has the same rotation as the camera, but is positioned at the origin of the world.\n    The .matrix, F, of frame f is just the camera matrix, except with the position component set to 0.\n     */\n    const frameMatrix = cameraMatrix.clone().setPosition(0, 0, 0);\n    const frameMatrixInv = frameMatrix.clone().invert();\n\n    /*\n    Construct a rotation matrix R that describes a rotation of offsetDegrees degrees about the y axis.\n     */\n    const rotationMatrix = new THREE.Matrix4().makeRotationY(MathUtils.degToRad(offsetDegrees));\n\n    /*\n    This matrix applies the rotation R with respect to the frame f. Applying it to the camera's local position gives the\n    desired world position and rotation of the light.\n\n    The matrix is calculated as F R F^(-1) C.\n     */\n    return frameMatrix.multiply(rotationMatrix).multiply(frameMatrixInv).multiply(cameraMatrix);\n}","import { Html } from \"@react-three/drei\";\nimport \"./styles/loading_screen.css\";\n\n/**\n * Loading screen. Covers the canvas when rendered.\n */\nexport function LoadingScreen() {\n    return (\n        <Html\n            transform={false}\n            fullscreen\n            className=\"loading-screen\"\n        >\n            <p className=\"loading-screen-text\">\n                Loading . . .\n            </p>\n        </Html>\n    );\n}","import React, { Suspense, useEffect } from \"react\";\nimport { useGLTF } from \"@react-three/drei\";\nimport { LoadingScreen } from \"./Loading\";\nimport { GEOID_NAME, MODEL_LAYER, MODEL_RADIUS } from \"../Constants\";\n\nconst GEOID_MODEL_PATH = \"./models/Geoid.glb\";\n\n/**\n * Imports the 3D model of the EGM2008 geoid (asset created specifically for this project).\n *\n * Auto-generated by: https://github.com/pmndrs/gltfjsx\n*/\nexport function Geoid({ isVisible, onGeoidLoad }) {\n    return (\n        <Suspense fallback={<LoadingScreen />}>\n            <GeoidModel isVisible={isVisible} onGeoidLoad={onGeoidLoad}/>\n        </Suspense>\n    );\n}\n\nfunction GeoidModel({isVisible, onGeoidLoad}) {\n    const { nodes, materials } = useGLTF(GEOID_MODEL_PATH);\n\n    useEffect(() => {\n        console.log(\"Loaded geoid model\");\n        onGeoidLoad();\n    }, []);\n\n    return (\n        <group dispose={null}>\n            <mesh\n                geometry={nodes.Sphere.geometry}\n                material={materials.GeoidFlatMaterial}\n\n                name={GEOID_NAME}\n                scale={MODEL_RADIUS}\n                layers={MODEL_LAYER}\n                visible={isVisible}\n            />\n        </group>\n    );\n}\n\nuseGLTF.preload(GEOID_MODEL_PATH);\n","import { SphereBufferGeometry } from \"three\";\nimport React, { useMemo } from \"react\";\nimport { HEIGHT_SEGMENTS, WIDTH_SEGMENTS } from \"../Constants\";\n\n/**\n * Displays a sphere, one of the 3 primary models in the visualization.\n */\nexport function Sphere(props) {\n    return (\n        <ScaledSphere\n            scale={1}\n            {...props}\n        />\n    );\n}\n\n/**\n * Displays an ellipsoid, one of the 3 primary models in the visualization.\n */\nexport function Ellipsoid(props) {\n    return (\n        <ScaledSphere\n            scale={[1, findSemiminorAxis(props.flattening, 1), 1]}\n            {...props}\n        />\n    );\n}\n\n/**\n * Computes the y-scale of the ellipsoid from the flattening factor.\n * @param flattening Flattening factor.\n * @param semimajorAxis The ellipsoid's x/z scales, assumed to be equal (semimajor axis).\n * @returns {number} The y-scale (semiminor axis).\n */\nfunction findSemiminorAxis(flattening, semimajorAxis) {\n    return (1 - flattening) * semimajorAxis;\n}\n\n/**\n * Draws a transparent sphere-like object with arbitrary x, y, and z scales.\n * This component is the basis for the sphere and ellipsoid models.\n */\nfunction ScaledSphere(props) {\n    const sphereGeometry = useMemo(() => {\n        return new SphereBufferGeometry(props.radius, WIDTH_SEGMENTS, HEIGHT_SEGMENTS);\n    }, [props.radius]);\n\n    return (\n        <group\n            scale={props.scale}\n        >\n            <mesh\n                geometry={sphereGeometry}\n                visible={props.opacity > 0}\n            >\n                <meshStandardMaterial\n                    attach=\"material\"\n                    color={props.color}\n                    transparent={true}\n                    opacity={props.opacity}\n                />\n            </mesh>\n            <lineSegments>\n                <edgesGeometry\n                    attach=\"geometry\"\n                    args={[sphereGeometry]}\n                />\n                <lineBasicMaterial\n                    attach=\"material\"\n                    color={props.edgeColor}\n                    transparent={true}\n                    opacity={props.opacity}\n                    depthWrite={false}\n                />\n            </lineSegments>\n        </group>\n    );\n}","import * as THREE from \"three\";\nimport { MathUtils } from \"three\";\nimport { MODEL_RADIUS } from \"./Constants\";\n\n/**\n * Converts a latitude angle between -90 and 90 degrees to polar angle in radians.\n * @param latitudeDeg Latitude, in degrees. Must be an integer value in [-90, 90].\n * @returns {*} Polar angle (spherical coordinates) in radians.\n */\nexport function convertLatitudeToSpherical(latitudeDeg) {\n    return MathUtils.degToRad(90 - latitudeDeg);\n}\n\n/**\n * Converts a longitude angle between -180 and 180 degrees to azimuthal angle in radians.\n * @param longitudeDeg Longitude, in degrees. Must be an integer value in [-180, 180].\n * @returns {*} Azimuthal angle (spherical coordinates) in radians.\n */\nexport function convertLongitudeToSpherical(longitudeDeg) {\n    return MathUtils.degToRad(longitudeDeg);\n}\n\n/**\n * Returns the point on the ellipsoid specified by the geocentric coordinates.\n * @param lat Latitude, in degrees.\n * @param lon Longitude, in degrees.\n * @param flattening Flattening factor of the ellipsoid.\n * @returns {Vector3} The world position of the intersection of the ellipsoid and the geocentric coordinates.\n */\nexport function geocentricEllipsoidIntersection(lat, lon, flattening) {\n    // World space position on the surface of the ellipsoid, from geocentric coordinates\n    // Formula source: https://en.wikipedia.org/wiki/Ellipsoid#Parameterization\n\n    const latRad = MathUtils.degToRad(lat);\n    const lonRad = MathUtils.degToRad(lon);\n\n    const z = Math.cos(latRad) * Math.cos(lonRad);\n    const x = Math.cos(latRad) * Math.sin(lonRad);\n    const y = Math.sin(latRad);\n\n    const R = (1 - flattening) * MODEL_RADIUS /\n        Math.sqrt(((1 - flattening) * Math.cos(latRad)) ** 2 + Math.sin(latRad) ** 2);\n\n    return new THREE.Vector3(x, y, z).multiplyScalar(R);\n}\n\n/**\n * Gets the world space coordinates from the geocentric latitude/longitude and height.\n * @param lat Latitude, in degrees.\n * @param lon Longitude, in degrees.\n * @param height Height (meters) above the sphere.\n * @returns {Vector3} The world position of the specified point.\n */\nexport function geocentricToWorld(lat, lon, height) {\n    const theta = convertLongitudeToSpherical(lon);\n    const phi = convertLatitudeToSpherical(lat);\n\n    return new THREE.Vector3().setFromSphericalCoords(MODEL_RADIUS + height, phi, theta);\n}\n\n/**\n * Gets the world space coordinates from the geodetic coordinates (latitude, longitude, ellipsoidal height).\n * @param lat Latitude, in degrees.\n * @param lon Longitude, in degrees.\n * @param flattening Flattening factor of the ellipsoid.\n * @param height Height (meters) above the ellipsoid.\n * @returns {Vector3} The world position of the specified point.\n */\nexport function geodeticToWorld(lat, lon, flattening, height) {\n    // Formula source: https://en.wikipedia.org/wiki/Geographic_coordinate_conversion#Coordinate_system_conversion\n    const latRad = MathUtils.degToRad(lat);\n    const lonRad = MathUtils.degToRad(lon);\n\n    const a = MODEL_RADIUS;\n    const eSquared = flattening * (2 - flattening);\n    const N = a / Math.sqrt(1 - eSquared * (Math.sin(latRad) ** 2));\n\n    const z = (N + height) * Math.cos(latRad) * Math.cos(lonRad);\n    const x = (N + height) * Math.cos(latRad) * Math.sin(lonRad);\n    const y = (N * (1 - eSquared) + height) * Math.sin(latRad);\n\n    return new THREE.Vector3(x, y, z);\n}\n\n/**\n * Returns the position of one endpoint of the geodetic coordinate line which lies on the equatorial plane.\n * @param lat Latitude, in degrees.\n * @param lon Longitude, in degrees.\n * @param flattening Flattening factor of the ellipsoid.\n * @returns {Vector3} The world position of this point.\n */\nexport function getGeodeticOrigin(lat, lon, flattening) {\n    const latRad = MathUtils.degToRad(lat);\n    const lonRad = MathUtils.degToRad(lon);\n\n    const a = MODEL_RADIUS;\n    const eSquared = flattening * (2 - flattening);\n    const N = a / Math.sqrt(1 - eSquared * (Math.sin(latRad) ** 2));\n\n    const z = eSquared * N * Math.cos(latRad) * Math.cos(lonRad);\n    const x = eSquared * N * Math.cos(latRad) * Math.sin(lonRad);\n\n    return new THREE.Vector3(x, 0, z);\n}","import * as THREE from \"three\";\nimport React, { useLayoutEffect, useRef } from \"react\";\nimport { MODEL_RADIUS } from \"../Constants\";\nimport { geocentricToWorld, geodeticToWorld, getGeodeticOrigin } from \"../CoordinateMath\";\n\n/**\n * Draws a line visualizing the given latitude and longitude as geocentric coordinates.\n */\nexport function GeocentricCoordinateLine({ latitude, longitude, lineColor }) {\n    return (\n        <MovingLine\n            start={new THREE.Vector3(0, 0, 0)}\n            end={geocentricToWorld(latitude, longitude, MODEL_RADIUS)}\n            lineColor={lineColor}\n\n            // Don't have this line cover the geodetic coordinate line\n            depthWrite={false}\n        />\n    );\n}\n\n/**\n * Draws a line visualizing the given latitude and longitude as geodetic coordinates.\n * (The flattening parametrizes the ellipsoid relative to which the geodetic coordinates are defined.)\n */\nexport function GeodeticCoordinateLine({latitude, longitude, flattening, lineColor}) {\n    return (\n        <MovingLine\n            start={getGeodeticOrigin(latitude, longitude, flattening)}\n            end={geodeticToWorld(latitude, longitude, flattening, MODEL_RADIUS)}\n            lineColor={lineColor}\n\n            renderOrder={2}\n            depthWrite={true}\n        />\n    );\n}\n\n/**\n * A line segment with dynamic endpoints.\n */\nfunction MovingLine(props) {\n    const bufferGeometryRef = useRef();\n\n    useLayoutEffect(() => {\n            const vertices = [\n                props.start,\n                props.end\n            ];\n            bufferGeometryRef.current.setFromPoints(vertices);\n        },\n        [props.start, props.end]\n    );\n\n    return (\n        <line\n            renderOrder={props.renderOrder ?? 0}\n        >\n            <bufferGeometry\n                attach=\"geometry\"\n                ref={bufferGeometryRef}\n            />\n            <lineBasicMaterial\n                attach=\"material\"\n                color={props.lineColor}\n                depthWrite={props.depthWrite}\n            />\n        </line>\n    );\n}\n","import { Html } from \"@react-three/drei\";\nimport React, { useEffect, useRef } from \"react\";\nimport \"./styles/geoid_height.css\";\n\nconst geoidHeightImageSrc = \"./geoid-height-grid.png\";\nconst geoidHeightCanvasId = \"geoid-height-grid\";\n\n/**\n * A hidden canvas containing a grid of geoid heights.\n * This canvas is used as a lookup table for the geoid height, so it must be included in the scene.\n */\nexport function GeoidHeightCanvas() {\n    const canvasRef = useRef();\n\n    useEffect(() => {\n        const image = new Image(361, 181);\n        image.src = geoidHeightImageSrc;\n\n        image.onload = () => {\n            console.log(\"Finished loading geoid height image.\");\n\n            const context = canvasRef.current.getContext(\"2d\");\n            context.drawImage( image, 0, 0 );\n        };\n    }, []);\n\n    return (\n        <Html>\n            <canvas\n                ref={canvasRef}\n                hidden\n                id={geoidHeightCanvasId}\n                width={361}\n                height={181}\n            />\n        </Html>\n    );\n}\n\n/**\n * Text overlaid on top of the scene, in the top center.\n */\nfunction CenteredText({ text }) {\n    return (\n        <Html\n            transform={false}\n            zIndexRange={[0, 0]}\n            className=\"geoid-height-label\"\n            style={{\n                \"position\": \"relative\",\n                \"left\": \"-50%\",\n            }}\n            calculatePosition={(el, camera, size) => [size.width / 2, 0]}\n        >\n            <p>\n                {text}\n            </p>\n        </Html>\n    )\n}\n\n/**\n * Displays the geoid height at the given latitude and longitude.\n */\nexport function GeoidHeightDisplay({ latitude, longitude }) {\n    const canvas = document.getElementById(geoidHeightCanvasId);\n\n    const context = canvas.getContext(\"2d\");\n    const geoidHeight = lookupGeoidHeight(context, latitude, longitude);\n\n    return (\n        <CenteredText\n            text = {`Geoid height: ${geoidHeight} m`}\n        />\n    );\n}\n\n/**\n * Finds the geoid height at the given coordinates.\n * @param context The 2d context of the canvas where the lookup image is stored.\n * @param lat Latitude, in degrees.\n * @param lon Longitude, in degrees.\n * @returns {number} The geoid height, in meters, rounded to the nearest integer.\n */\nfunction lookupGeoidHeight( context, lat, lon ) {\n    const [ imgX, imgY ] = getImgXYFromCoordinates(lon, lat);\n\n    const data = context.getImageData(imgX, imgY, 1, 1).data;\n\n    return pixelToGeoidHeight(data[0]);\n}\n\nfunction getImgXYFromCoordinates(lon, lat) {\n    return [lon + 180 , 90 - lat]\n}\n\n/**\n * Decodes the rounded geoid height from the stored pixel value.\n *\n * The geoid heights were stored according to a linear scale, where pixel=0 corresponds to the minimum geoid height\n * in the dataset, and pixel=255 corresponds to the maximum.\n * @param pixelValue The value of the pixel in the lookup image. Should be an integer in [0, 255].\n * @returns {number} The geoid height, in meters, rounded to the nearest integer.\n */\nfunction pixelToGeoidHeight(pixelValue) {\n    const maxHeight = 78.21;\n    const minHeight = -106.57;\n\n    const height = minHeight + pixelValue / 255 * (maxHeight - minHeight);\n\n    return Math.round(height);\n}","import React, { useRef, useState } from \"react\";\nimport { useFrame } from \"@react-three/fiber\";\nimport { MODEL_RADIUS } from \"../Constants\";\n\n/**\n * The color of a {@link SpherePoint} when not hovered over.\n * @type {string}\n */\nconst NORMAL_COLOR = \"#00ffbb\";\n\n/**\n * The color of a {@link SpherePoint} when hovered over.\n * @type {string}\n */\nconst HOVER_COLOR = \"#ff0090\";\n\n/**\n * A small spherical point that can be placed at a given world position in the scene.\n * Changes color when hovered over.\n */\nexport function SpherePoint({ position }) {\n    const materialRef = useRef();\n    const [hover, setHover] = useState(false);\n\n    useFrame(() => {\n        materialRef.current.color.set(hover ? HOVER_COLOR : NORMAL_COLOR);\n    });\n\n    return (\n        <mesh\n            position={position}\n\n            onPointerOver={() => setHover(true)}\n            onPointerOut={() => setHover(false)}\n        >\n            <sphereBufferGeometry\n                attach=\"geometry\"\n                args={[MODEL_RADIUS / 80, 10, 5]}\n            />\n            <meshStandardMaterial\n                attach=\"material\"\n                ref={materialRef}\n                color={NORMAL_COLOR}\n            />\n        </mesh>\n    );\n}","import React, { useMemo } from \"react\";\nimport * as THREE from \"three\";\nimport { SpherePoint } from \"./SpherePoint\";\nimport { MODEL_LAYER, MODEL_RADIUS } from \"../Constants\";\nimport { geocentricEllipsoidIntersection, geocentricToWorld, geodeticToWorld, } from \"../CoordinateMath\";\nimport { useThree } from \"@react-three/fiber\";\n\n/**\n * Draws the point on the sphere given by the geocentric latitude and longitude.\n */\nexport function SphereIntersection( {latitude, longitude} ) {\n    return (\n        <SpherePoint\n            position={geocentricToWorld(latitude, longitude, 0)}\n        />\n    );\n}\n\n/**\n * Draws the point on the ellipsoid given by the geocentric latitude and longitude.\n */\nexport function GeocentricEllipsoidIntersection({latitude, longitude, flattening} ) {\n    return (\n        <SpherePoint\n            position={geocentricEllipsoidIntersection(latitude, longitude, flattening)}\n        />\n    );\n}\n\n/**\n * Draws the point on the ellipsoid given by the geodetic latitude and longitude.\n */\nexport function GeodeticEllipsoidIntersection({latitude, longitude, flattening}) {\n    return (\n        <SpherePoint\n            position={geodeticToWorld(latitude, longitude, flattening, 0)}\n        />\n    );\n}\n\n/**\n * Draws a point on the specified model that corresponds to the given geocentric latitude and longitude.\n *\n * Uses the first model in MODEL_LAYER whose .name equals the given name.\n */\nexport function GeocentricRaycastIntersectionByName({ latitude, longitude, objectName } ) {\n    const rayStart = geocentricToWorld(latitude, longitude, MODEL_RADIUS);\n\n    return (\n        <RaycastIntersectionByName\n            rayStart={rayStart}\n            direction={rayStart.clone().negate()}\n            objectName={objectName}\n        />\n    );\n}\n\n/**\n * Draws a point on the specified model that corresponds to the geodetic latitude and longitude.\n *\n * Uses the first model in MODEL_LAYER whose .name equals the given name.\n */\nexport function GeodeticRaycastIntersectionByName({ latitude, longitude, flattening, objectName }) {\n    const rayStart = geodeticToWorld(latitude, longitude, flattening, MODEL_RADIUS);\n    const direction = geodeticToWorld(latitude, longitude, flattening, -MODEL_RADIUS / 2).sub(rayStart);\n\n    return (\n        <RaycastIntersectionByName\n            rayStart={rayStart}\n            direction={direction}\n            objectName={objectName}\n        />\n    );\n}\n\n/**\n * Draws a point on the given object that corresponds to the geocentric latitude and longitude.\n */\nexport function GeocentricRaycastIntersectionByObject({ latitude, longitude, object }) {\n    const rayStart = geocentricToWorld(latitude, longitude, MODEL_RADIUS);\n\n    return (\n        <RaycastIntersectionByObject\n            rayStart={rayStart}\n            direction={rayStart.clone().negate()}\n            object={object}\n        />\n    );\n}\n\n/**\n * Draws a point on the given object that corresponds to the geodetic latitude and longitude.\n */\nexport function GeodeticRaycastIntersectionByObject({ latitude, longitude, flattening, object }) {\n    const rayStart = geodeticToWorld(latitude, longitude, flattening, MODEL_RADIUS);\n    const direction = geodeticToWorld(latitude, longitude, flattening, -MODEL_RADIUS / 2).sub(rayStart);\n\n    return (\n        <RaycastIntersectionByObject\n            rayStart={rayStart}\n            direction={direction}\n            object={object}\n        />\n    );\n}\n\n/**\n * Raycasts against an object and draws the first intersection it finds (or nothing, if no intersection).\n * The raycasting uses the layer MODEL_LAYER.\n * @param rayStart Start position of the ray (Vector3).\n * @param direction Direction to raycast in (Vector3). Can be any length, the function will normalize it.\n * @param object The Object3D to intersect.\n */\nfunction RaycastIntersectionByObject({rayStart, direction, object}) {\n    const raycaster = useMemo(() => {\n        const r = new THREE.Raycaster();\n        r.layers.set(MODEL_LAYER);\n\n        return r;\n    }, []);\n\n    if (object) {\n        raycaster.set(rayStart, direction.normalize());\n\n        const intersections = raycaster.intersectObject(object);\n\n        console.log(\"Performed a raycast: \");\n        console.log(intersections[0]);\n\n        if (intersections[0]) {\n            return (\n                <SpherePoint\n                    position={intersections[0].point}\n                />\n            );\n        }\n    }\n\n    return null;\n}\n\n/**\n * Raycasts against the whole scene and finds the first intersection with an object that has the given name.\n * The raycasting uses the layer MODEL_LAYER.\n * @param rayStart Start position of the ray (Vector3).\n * @param direction Direction to raycast in (Vector3). Can be any length, the function will normalize it.\n * @param objectName The Object3D to intersect.\n */\nfunction RaycastIntersectionByName({rayStart, direction, objectName}) {\n    const { scene } = useThree();\n\n    const raycaster = useMemo(() => {\n        const r = new THREE.Raycaster();\n        r.layers.set(MODEL_LAYER);\n\n        return r;\n    }, []);\n\n    raycaster.set(rayStart, direction.normalize());\n\n    const intersections = raycaster.intersectObjects(scene.children, true);\n    const modelIntersection = intersections.find((intersection) => intersection.object.name === objectName);\n\n    console.log(\"Performed a raycast: \");\n    console.log(modelIntersection);\n\n    if (modelIntersection) {\n        return (\n            <SpherePoint\n                position={modelIntersection.point}\n            />\n        );\n    }\n\n    return null;\n}\n\nexport function geocentricRaycast(scene, raycaster, latitude, longitude, objectName) {\n    const rayStart = geocentricToWorld(latitude, longitude, MODEL_RADIUS);\n    const direction = rayStart.clone().negate();\n\n    return raycast(scene, raycaster, rayStart, direction, objectName);\n}\n\nexport function geodeticRaycast(scene, raycaster, latitude, longitude, flattening, objectName) {\n    const rayStart = geodeticToWorld(latitude, longitude, flattening, MODEL_RADIUS);\n    const direction = geodeticToWorld(latitude, longitude, flattening, -MODEL_RADIUS / 2).sub(rayStart);\n\n    return raycast(scene, raycaster, rayStart, direction, objectName);\n}\n\nfunction raycast(scene, raycaster, rayStart, direction, objectName) {\n    raycaster.set(rayStart, direction.normalize());\n\n    const intersections = raycaster.intersectObjects(scene.children, true);\n    const intersection = intersections.find((intersection) => intersection.object.name === objectName);\n\n    console.log(\"Performed a raycast: \");\n    console.log(intersection);\n\n    return intersection ? intersection.point : null;\n}","import { Html } from \"@react-three/drei\";\nimport \"./styles/legend.css\";\n\n/**\n * Takes 2 legend elements and groups them with the proper position and alignment.\n */\nexport function LegendWrapper({gradientLegend, elementsLegend}) {\n    return (\n        <Html\n            calculatePosition={(el, camera, size) => {\n                return [0, size.height];\n            }}\n            prepend\n            zIndexRange={[0, 0]}\n            className=\"legends-root\"\n        >\n            <div className=\"legends-wrapper\">\n                {elementsLegend}\n                {gradientLegend}\n            </div>\n        </Html>\n    )\n}\n\n/**\n * Legend for the colour gradient on the geoid.\n * @param top Label for the maximum value.\n * @param middle Label for the middle value.\n * @param bottom Label for the minimum value.\n */\nexport function GradientLegend({top, middle, bottom}) {\n    return (\n        <div className=\"gradient-legend-wrapper\">\n            <img\n                id=\"horizontal-gradient\"\n                src={\"geoid-gradient-legend-horizontal.png\"}\n                alt={\"geoid gradient legend\"}\n            />\n            <img\n                id=\"vertical-gradient\"\n                src={\"geoid-gradient-legend-vertical.png\"}\n                alt={\"geoid gradient legend\"}\n            />\n\n            <div className=\"gradient-labels-wrapper\">\n                <div className=\"legend-text\">\n                    {top}\n                </div>\n                <div className=\"legend-text\">\n                    {middle}\n                </div>\n                <div className=\"legend-text\">\n                    {bottom}\n                </div>\n            </div>\n        </div>\n    );\n}\n\n/**\n * Legend for the different objects in the visualization.\n * @param elements Items to show in the legend. Items should have structure\n * {\n *      label: <the item's label>,\n *      block: <the item's symbol; use a ___Block component>,\n * }\n */\nexport function Legend({elements}) {\n    return (\n        <ul className=\"list-legend-wrapper\">\n            {Object.keys(elements).map((label) => (\n                <LegendElement key={label}\n                               block={elements[label]}\n                               label={label} />\n            ))}\n        </ul>\n    );\n}\n\nfunction LegendElement({ block, label }) {\n    return (\n        <li className=\"legend-item-wrapper\">\n            {block}\n            <span className=\"legend-text legend-value\">\n                {label}\n            </span>\n        </li>\n    );\n}\n\n/**\n * Legend symbol of a line with the given colour.\n */\nexport function LineBlock({ color }) {\n    return (\n        <span className=\"legend-key\">\n            <hr\n                style={{\n                    borderWidth: \"1px 0 0 0\",\n                    borderStyle: \"solid\",\n                    borderColor: color,\n                }}\n            />\n        </span>\n    );\n}\n\n/**\n * Legend symbol from an image.\n */\nexport function ImageBlock({ src, alt }) {\n    return (\n        <img\n            className=\"legend-key\"\n            src={src}\n            alt={alt}\n        />\n    );\n}\n\n/**\n * Legend symbol for a colour.\n */\nexport function ColorBlock({ color }) {\n    return (\n        <span\n            className=\"legend-key\"\n            style={{\n                backgroundColor: color ?? \"white\",\n            }}\n        />\n    );\n}","import { buttonGroup, folder, useControls } from \"leva\";\nimport React, { useEffect, useMemo, useState } from \"react\";\nimport { Geoid } from \"./Geoid\";\nimport { Ellipsoid, Sphere } from \"./Spheroids\";\nimport { GeocentricCoordinateLine, GeodeticCoordinateLine } from \"./CoordinateLine\";\nimport { GeoidHeightCanvas, GeoidHeightDisplay } from \"./GeoidHeightDisplay\";\nimport {\n    GeocentricEllipsoidIntersection,\n    geocentricRaycast,\n    GeodeticEllipsoidIntersection,\n    geodeticRaycast,\n    SphereIntersection\n} from \"./Intersections\";\nimport {\n    COORDINATES_FOLDER,\n    ELLIPSOID_COLOR,\n    ELLIPSOID_CONTROL_HINT,\n    FLATTENING_CONTROL_HINT,\n    GEOCENTRIC_CONTROL_HINT,\n    GEOCENTRIC_LINE_COLOR,\n    GEODETIC_CONTROL_HINT,\n    GEODETIC_LINE_COLOR,\n    GEOID_CONTROL,\n    GEOID_CONTROL_HINT,\n    GEOID_HEIGHT_CONTROL,\n    GEOID_NAME,\n    GRATICULE_COLOR,\n    LATITUDE_CONTROL_HINT,\n    LEGEND_ELLIPSOID,\n    LEGEND_GEOCENTRIC,\n    LEGEND_GEODETIC,\n    LEGEND_GEOID,\n    LEGEND_SPHERE,\n    LONGITUDE_CONTROL_HINT,\n    MODEL_LAYER,\n    MODEL_RADIUS,\n    MODELS_FOLDER,\n    SPHERE_COLOR,\n    SPHERE_CONTROL_HINT,\n    VANCOUVER_LATITUDE,\n    VANCOUVER_LONGITUDE,\n    WGS_FLATTENING\n} from \"../Constants\";\nimport { ColorBlock, GradientLegend, ImageBlock, Legend, LegendWrapper, LineBlock } from \"./Legend\";\nimport { useThree } from \"@react-three/fiber\";\nimport * as THREE from \"three\";\nimport { SpherePoint } from \"./SpherePoint\";\n\n/**\n * Renders the main content of the visualization, including coordinate lines, models, etc.\n */\nexport function Visualization() {\n    const {latitude, longitude} = useControls(COORDINATES_FOLDER, {\n        latitude: {\n            value: VANCOUVER_LATITUDE,\n            min: -90,\n            max: 90,\n            step: 1,\n            hint: LATITUDE_CONTROL_HINT,\n            label: \"λ (latitude)\",\n        },\n        longitude: {\n            value: VANCOUVER_LONGITUDE,\n            min: -180,\n            max: 180,\n            step: 1,\n            hint: LONGITUDE_CONTROL_HINT,\n            label: \"φ (longitude)\",\n        }\n    });\n\n    const [{ [GEOID_HEIGHT_CONTROL]: geoidHeightMode, geodetic, geocentric }, set] = useControls(() => ({\n        [MODELS_FOLDER]: folder(\n            {\n                [GEOID_HEIGHT_CONTROL]: {\n                    value: false,\n                    render: () => false,\n                },\n                \"geoid height\": buttonGroup({\n                    \"on\": () => set({\n                        [GEOID_HEIGHT_CONTROL]: true,\n                        geodetic: true,\n                        geocentric: false,\n                    }),\n                    \"off\": () => set({\n                        [GEOID_HEIGHT_CONTROL]: false,\n                    }),\n                }),\n            }\n        ),\n        [COORDINATES_FOLDER]: folder(\n            {\n                geodetic: {\n                    value: true,\n                    render: (get) => !get(`${MODELS_FOLDER}.${GEOID_HEIGHT_CONTROL}`),\n                    hint: GEODETIC_CONTROL_HINT,\n                },\n                geocentric: {\n                    value: false,\n                    render: (get) => !get(`${MODELS_FOLDER}.${GEOID_HEIGHT_CONTROL}`),\n                    hint: GEOCENTRIC_CONTROL_HINT,\n                },\n            }\n        ),\n    }));\n\n    return (\n        <>\n            <GeoidHeightCanvas/>\n            <Models\n                latitude={latitude}\n                longitude={longitude}\n                geoidHeightMode={geoidHeightMode}\n                geodetic={geodetic}\n                geocentric={geocentric}\n            />\n            {\n                geoidHeightMode ?\n                <GeoidHeightDisplay\n                    latitude={latitude}\n                    longitude={longitude}\n                /> : null\n            }\n        </>\n    );\n}\n\nfunction Models({ latitude, longitude, geoidHeightMode, geocentric, geodetic }) {\n    const [ { sphere, ellipsoid, flattening }, setModels ] = useControls(MODELS_FOLDER, () => ({\n        sphere: {\n            value: 0,\n            min: 0,\n            max: 1,\n            render: (get) => !get(`${MODELS_FOLDER}.${GEOID_HEIGHT_CONTROL}`),\n            hint: SPHERE_CONTROL_HINT,\n        },\n        ellipsoid: {\n            value: 0,\n            min: 0,\n            max: 1,\n            hint: ELLIPSOID_CONTROL_HINT,\n        },\n        flattening: {\n            value: 0.15,\n            min: 0,\n            max: 1,\n            render: (get) => !get(`${MODELS_FOLDER}.${GEOID_HEIGHT_CONTROL}`),\n            hint: FLATTENING_CONTROL_HINT,\n        },\n    }));\n\n    const [{ [GEOID_CONTROL] : geoid }, setGeoid] = useControls(MODELS_FOLDER, () => ({\n        [GEOID_CONTROL]: {\n            value: true,\n            render: (get) => !get(`${MODELS_FOLDER}.${GEOID_HEIGHT_CONTROL}`),\n            hint: GEOID_CONTROL_HINT,\n            onChange: (value) => {\n                if (value) {\n                    setModels({\n                        sphere: 0,\n                        ellipsoid: 0,\n                    });\n                }\n            },\n            transient: false,\n        },\n    }));\n\n    // When the geoid height view is turned on, makes the geoid visible.\n    useEffect(() => {\n        if (geoidHeightMode) {\n            setGeoid({ [GEOID_CONTROL]: true });\n        }\n    }, [geoidHeightMode, setGeoid]);\n\n    // When the geoid height view is turned on, hides the sphere and sets a default flattening.\n    useEffect(() => {\n        if (geoidHeightMode) {\n            setModels({\n                sphere: 0,\n                flattening: WGS_FLATTENING,\n            });\n        }\n    }, [geoidHeightMode, setModels]);\n\n    // When sphere is fully opaque, decreases the sphere opacity so it is clear that the ellipsoid is behind it.\n    useEffect(() => {\n        if (sphere === 1) {\n            setModels({ sphere: 0.5 });\n        }\n    }, [ellipsoid, flattening, setModels]);\n\n    const { scene } = useThree();\n\n    const raycaster = useMemo(() => {\n        const r = new THREE.Raycaster();\n        r.layers.set(MODEL_LAYER);\n\n        return r;\n    }, []);\n\n    const [shouldUpdate, setShouldUpdate] = useState(false);\n    const [geodeticIntersection, setGeodeticIntersection] = useState();\n    const [geocentricIntersection, setGeocentricIntersection] = useState();\n\n    useEffect(() => {\n        if (geodetic) {\n            setGeodeticIntersection(geodeticRaycast(scene, raycaster, latitude, longitude, flattening, GEOID_NAME));\n        }\n    }, [scene, raycaster, latitude, longitude, flattening, geodetic, shouldUpdate]);\n\n    useEffect(() => {\n        if (geocentric) {\n            setGeocentricIntersection(geocentricRaycast(scene, raycaster, latitude, longitude, GEOID_NAME));\n        }\n    }, [scene, raycaster, latitude, longitude, geocentric, shouldUpdate]);\n\n    const gradientLegend = (\n        geoid ?\n            <GradientLegend top={\"78 m\"} middle={\"Ellipsoid\"} bottom={\"-106 m\"}/>\n            : null\n    );\n\n    const legend = <Legend elements={getLegendElements(sphere > 0, ellipsoid > 0, geoid, geocentric, geodetic)}/>;\n\n    return (\n        <>\n            <Ellipsoid\n                opacity={ellipsoid}\n                flattening={flattening}\n                color={ELLIPSOID_COLOR}\n                edgeColor={GRATICULE_COLOR}\n                radius={MODEL_RADIUS}\n            />\n            <Sphere\n                opacity={sphere}\n                color={SPHERE_COLOR}\n                edgeColor={GRATICULE_COLOR}\n                radius={MODEL_RADIUS}\n            />\n            {\n                geocentric ? (\n                    <GeocentricCoordinateLine\n                        latitude={latitude}\n                        longitude={longitude}\n                        lineColor={GEOCENTRIC_LINE_COLOR}\n                    />\n                ) : null\n            }\n            {\n                geodetic ? (\n                    <GeodeticCoordinateLine\n                        latitude={latitude}\n                        longitude={longitude}\n                        flattening={flattening}\n                        lineColor={GEODETIC_LINE_COLOR}\n                    />\n                ) : null\n            }\n            {\n                geocentric && (sphere > 0) ? (\n                    <SphereIntersection\n                        latitude={latitude}\n                        longitude={longitude}\n                    />\n                ) : null\n            }\n            {\n                geodetic && (ellipsoid > 0) ? (\n                    <GeodeticEllipsoidIntersection\n                        latitude={latitude}\n                        longitude={longitude}\n                        flattening={flattening}\n                    />\n                ) : null\n            }\n            {\n                geocentric && (ellipsoid > 0) ? (\n                    <GeocentricEllipsoidIntersection\n                        latitude={latitude}\n                        longitude={longitude}\n                        flattening={flattening}\n                    />\n                ) : null\n            }\n            <Geoid\n                isVisible={geoid}\n                onGeoidLoad={() => {\n                    setShouldUpdate(!shouldUpdate);\n                }}\n            />\n            {\n                geoid && geocentric ?\n                    <SpherePoint position={geocentricIntersection}/>\n                    : null\n            }\n            {\n                geoid && geodetic ?\n                    <SpherePoint position={geodeticIntersection}/>\n                    : null\n            }\n            <LegendWrapper gradientLegend={gradientLegend} elementsLegend={legend}/>\n        </>\n    );\n}\n\nfunction getLegendElements(sphere, ellipsoid, geoid, geocentric, geodetic) {\n    const elements = {};\n\n    if (geoid) {\n        elements[LEGEND_GEOID] = <ImageBlock src={\"geoid-gradient.png\"} alt={\"A legend for the geoid colour gradient\"}/>;\n    }\n\n    if (ellipsoid) {\n        elements[LEGEND_ELLIPSOID] = <ColorBlock color={ELLIPSOID_COLOR}/>;\n    }\n\n    if (sphere) {\n        elements[LEGEND_SPHERE] = <ColorBlock color={SPHERE_COLOR}/>;\n    }\n\n    if (geodetic) {\n        elements[LEGEND_GEODETIC] = <LineBlock color={GEODETIC_LINE_COLOR}/>;\n    }\n\n    if (geocentric) {\n        elements[LEGEND_GEOCENTRIC] = <LineBlock color={GEOCENTRIC_LINE_COLOR}/>;\n    }\n\n    return elements;\n}","import { Html } from \"@react-three/drei\";\nimport \"./styles/link_back.css\";\n\nexport function LinkBack({ url }) {\n    return (\n        <Html\n            calculatePosition={(el, camera, size) => [0, size.height]}\n            zIndexRange={[0, 0]}\n        >\n            <div className=\"link-back\" >\n                <a\n                    href={url}\n                    target=\"_blank\"\n                    rel=\"noreferrer noopener\"\n                >\n                    Back to textbook\n                </a>\n            </div>\n        </Html>\n    );\n}","import React from 'react'\nimport { Canvas } from '@react-three/fiber'\nimport './styles.css'\nimport { CameraAlignedLight, FreeControlsWithClickDetection, SetCameraLayers, } from \"./Components/ControlsAndLight\";\nimport { Visualization } from \"./Components/Visualization\";\nimport { Stats } from \"@react-three/drei\";\nimport { Leva } from 'leva';\nimport { MODEL_RADIUS } from \"./Constants\";\nimport { LinkBack } from \"./Components/LinkBack\";\n\nfunction App() {\n    return (\n        <>\n            <Canvas\n                camera={{\n                    position: [MODEL_RADIUS * 2 + 0.5, 0, 0]\n                }}\n            >\n                <SetCameraLayers/>\n                <ambientLight intensity={0.15}/>\n\n                <Visualization/>\n\n                <CameraAlignedLight/>\n                <FreeControlsWithClickDetection/>\n\n                <Stats />\n                <LinkBack url={\"https://ubc-geomatics-textbook.github.io/geomatics-textbook/mapping-data.html\"}/>\n            </Canvas>\n            <Leva hideCopyButton={true} />\n        </>\n    );\n}\n\nexport default App;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport App from './App';\n\nReactDOM.render(\n    <App />,\n  document.getElementById('root')\n);\n"],"sourceRoot":""}